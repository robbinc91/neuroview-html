<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NeuroView Web Pro</title>
    <meta name="description" content="NeuroView Web - High-performance NIfTI/MRI viewer in the browser">
    <meta name="theme-color" content="#000000">
    <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='8' fill='%230ea5e9'/%3E%3C/svg%3E">
    <script src="tailwindscss.js"></script>
    <script src="pako.min.js" defer></script>
    <!-- Optional libraries loaded lazily on demand -->
    <script src="https://unpkg.com/nifti-reader-js/dist/nifti-reader.min.js" defer></script>
    <style>
        body {
            background-color: #000;
            color: #e5e5e5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f1f1f;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .viewport {
            position: relative;
            border: 2px solid #262626;
            background-color: #000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .viewport.active {
            border-color: #0ea5e9;
            /* Sky-500 */
        }

        .viewport canvas {
            display: block;
            /* Canvas size is handled by JS for perfect fit */
        }

        .overlay-text {
            position: absolute;
            top: 4px;
            left: 4px;
            font-family: monospace;
            font-size: 12px;
            color: #38bdf8;
            background-color: rgba(0, 0, 0, 0.7);
            /* Slightly darker for better contrast */
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 10;
            display: flex;
            /* Added */
            align-items: center;
            /* Added */
            gap: 8px;
            /* Added space between text and button */
        }

        input[type=range] {
            height: 4px;
            border-radius: 2px;
            background: #404040;
            outline: none;
            appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #0ea5e9;
            cursor: pointer;
            margin-top: -6px;
            /* center thumb */
        }

        input[type=range]::-webkit-slider-runnable-track {
            height: 4px;
            background: #404040;
            border-radius: 2px;
        }

        input[type=range]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Fullscreen/Maximize logic */
        .viewport.maximized {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 40;
            /* Above other viewports */
        }

        .view-control-btn {
            pointer-events: auto;
            cursor: pointer;
            background: rgba(38, 38, 38, 0.8);
            border-radius: 4px;
            padding: 2px 6px;
            margin-left: 8px;
            transition: background 0.2s;
        }

        .view-control-btn:hover {
            background: #0ea5e9;
            color: white;
        }

        /* Ensure the grid container is the reference for absolute positioning */

        .lazy-loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            color: #94a3b8;
            font-size: 13px;
            gap: 12px;
        }

        .lazy-loading-overlay.hidden {
            display: none;
        }

        .lazy-spinner {
            width: 32px;
            height: 32px;
            border: 2px solid #334155;
            border-top-color: #0ea5e9;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .progress-bar {
            width: 120px;
            height: 4px;
            background: #334155;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0ea5e9;
            width: 0%;
            transition: width 0.3s ease;
        }

        #main-grid-container {
            position: relative;
        }

        /* Drag & Drop Overlay */
        .drag-overlay {
            position: fixed;
            inset: 0;
            background: rgba(14, 165, 233, 0.15);
            border: 4px dashed #0ea5e9;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .drag-overlay.hidden {
            display: none;
        }

        .drag-overlay-text {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 12px;
            color: #0ea5e9;
            font-size: 18px;
            font-weight: bold;
        }

        /* Measurement line on canvas */
        .measurement-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: #22c55e;
            font-family: monospace;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 15;
            white-space: nowrap;
        }

        /* Keyboard Shortcuts Help Modal */
        .shortcuts-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 300;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shortcuts-modal.hidden {
            display: none;
        }

        .shortcuts-content {
            background: #1f1f1f;
            border: 1px solid #404040;
            border-radius: 12px;
            padding: 24px 32px;
            max-width: 500px;
            color: #e5e5e5;
        }

        .shortcuts-content h2 {
            margin-bottom: 16px;
            color: #0ea5e9;
            font-size: 18px;
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #333;
        }

        .shortcut-key {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            color: #0ea5e9;
        }

        /* Undo/Redo buttons */
        .undo-redo-btn {
            width: 40px;
            height: 32px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Collapsible Sidebar */
        .sidebar {
            transition: width 0.3s ease, min-width 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
        }

        .sidebar.collapsed {
            width: 48px !important;
            min-width: 48px !important;
        }

        .sidebar.collapsed .sidebar-content {
            opacity: 0;
            pointer-events: none;
        }

        .sidebar.collapsed .sidebar-header h1,
        .sidebar.collapsed .sidebar-header p {
            display: none;
        }

        .sidebar-toggle {
            position: absolute;
            right: -14px;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 48px;
            background: #262626;
            border: 1px solid #404040;
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            z-index: 20;
            transition: background 0.2s, color 0.2s;
        }

        .sidebar-toggle:hover {
            background: #0ea5e9;
            color: white;
        }

        /* Intensity Histogram */
        .histogram-container {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
        }

        .histogram-canvas {
            width: 100%;
            height: 80px;
            background: #0f0f0f;
            border-radius: 4px;
            cursor: crosshair;
        }

        .histogram-info {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }

        .histogram-cursor {
            position: absolute;
            width: 1px;
            background: #0ea5e9;
            pointer-events: none;
        }

        /* Screenshot button */
        .screenshot-btn {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
        }

        .screenshot-btn:hover {
            background: linear-gradient(135deg, #818cf8, #a78bfa);
        }
    </style>
</head>

<body>

    <noscript class="p-4 text-sm text-yellow-300 bg-neutral-900">JavaScript is required to run NeuroView Web. Please
        enable JavaScript in your browser.</noscript>

    <!-- Drag & Drop Overlay -->
    <div id="drag-overlay" class="drag-overlay hidden">
        <div class="drag-overlay-text">üìÇ Drop NIfTI file to load</div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div id="shortcuts-modal" class="shortcuts-modal hidden">
        <div class="shortcuts-content">
            <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
            <div class="shortcut-row"><span>Focus Axial View</span><span class="shortcut-key">1</span></div>
            <div class="shortcut-row"><span>Focus Coronal View</span><span class="shortcut-key">2</span></div>
            <div class="shortcut-row"><span>Focus Sagittal View</span><span class="shortcut-key">3</span></div>
            <div class="shortcut-row"><span>Focus 3D View</span><span class="shortcut-key">4</span></div>
            <div class="shortcut-row"><span>Navigate Slices</span><span class="shortcut-key">‚Üë ‚Üì</span></div>
            <div class="shortcut-row"><span>Navigate Tool</span><span class="shortcut-key">N</span></div>
            <div class="shortcut-row"><span>Brush Tool</span><span class="shortcut-key">B</span></div>
            <div class="shortcut-row"><span>Eraser Tool</span><span class="shortcut-key">E</span></div>
            <div class="shortcut-row"><span>Measure Tool</span><span class="shortcut-key">M</span></div>
            <div class="shortcut-row"><span>Undo</span><span class="shortcut-key">Ctrl+Z</span></div>
            <div class="shortcut-row"><span>Redo</span><span class="shortcut-key">Ctrl+Y</span></div>
            <div class="shortcut-row"><span>Reset View</span><span class="shortcut-key">R</span></div>
            <div class="shortcut-row"><span>Toggle Sidebar</span><span class="shortcut-key">Tab</span></div>
            <div class="shortcut-row"><span>Close this help</span><span class="shortcut-key">? / Esc</span></div>
            <button id="btn-close-shortcuts"
                class="w-full mt-4 py-2 px-4 rounded bg-sky-600 hover:bg-sky-500 text-white font-medium">Close</button>
        </div>
    </div>


    <div class="flex h-screen w-screen">
        <!-- Sidebar -->
        <div id="sidebar"
            class="sidebar w-80 bg-neutral-900 border-r border-neutral-800 flex flex-col text-sm h-full z-10 shadow-xl relative">
            <!-- Toggle Button -->
            <button id="sidebar-toggle" class="sidebar-toggle" title="Toggle Sidebar (Tab)">‚óÄ</button>

            <div class="sidebar-header p-4 border-b border-neutral-800">
                <h1 class="text-xl font-bold text-sky-500 tracking-tight">NeuroView <span class="text-white">Web</span>
                </h1>
                <p class="text-neutral-500 text-xs mt-1">High-Performance NIfTI Viewer</p>
            </div>

            <div class="sidebar-content p-4 space-y-6 overflow-y-auto flex-1">

                <!-- File Operations -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Data Source</h2>

                    <div class="grid grid-cols-2 gap-2">
                        <button id="btn-load-mri"
                            class="py-2 px-3 rounded text-white font-medium bg-sky-700 hover:bg-sky-600 transition-colors">
                            Load MRI
                        </button>
                        <button id="btn-load-mask"
                            class="py-2 px-3 rounded text-white font-medium bg-neutral-700 hover:bg-neutral-600 transition-colors">
                            Load Mask
                        </button>
                    </div>

                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <button id="btn-load-mri2"
                            class="py-2 px-3 rounded text-white font-medium bg-purple-700 hover:bg-purple-600 transition-colors">
                            Load MRI 2
                        </button>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="check-dual-view" class="w-4 h-4 accent-sky-500">
                            <label for="check-dual-view" class="text-xs text-neutral-300">Enable Dual View</label>
                        </div>
                    </div>

                    <button id="btn-generate"
                        class="w-full py-2 px-3 rounded text-neutral-300 font-medium bg-neutral-800 hover:bg-neutral-700 transition-colors border border-neutral-700">
                        Generate Phantom
                    </button>

                    <!-- Hidden Inputs -->
                    <input type="file" id="input-file-mri" class="hidden" accept=".nii,.nii.gz,.img,.hdr">
                    <input type="file" id="input-file-mask" class="hidden" accept=".nii,.nii.gz,.img,.hdr">
                    <input type="file" id="input-file-mri2" class="hidden" accept=".nii,.nii.gz,.img,.hdr">
                    <input type="file" id="input-file-label-config" class="hidden" accept=".json">

                    <div class="mt-2 grid grid-cols-2 gap-2">
                        <button id="btn-load-label-config"
                            class="py-2 px-3 rounded text-white font-medium bg-emerald-700 hover:bg-emerald-600 transition-colors">Load
                            Label Config</button>
                        <button id="btn-save-label-config"
                            class="py-2 px-3 rounded text-white font-medium bg-amber-700 hover:bg-amber-600 transition-colors">Save
                            Label Config</button>
                    </div>

                    <!-- Label Colors (dynamic) -->
                    <div id="label-colors-section" class="pt-3">
                        <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Label Colors</h2>
                        <div id="label-colors" class="mt-2 space-y-2 text-sm text-white"></div>
                        <div class="mt-2 grid grid-cols-2 gap-2">
                            <button id="btn-reset-label-colors"
                                class="py-2 px-3 rounded text-white font-medium bg-neutral-700 hover:bg-neutral-600 transition-colors">Reset
                                Colors</button>
                            <button id="btn-refresh-label-colors"
                                class="py-2 px-3 rounded text-white font-medium bg-sky-600 hover:bg-sky-500 transition-colors">Refresh</button>
                        </div>
                    </div>

                    <button id="btn-calc-volumes"
                        class="w-full mt-2 py-2 px-3 rounded text-neutral-300 font-medium bg-neutral-800 hover:bg-neutral-700 transition-colors border border-neutral-700">Calculate
                        Volumes</button>

                    <div id="loading-indicator"
                        class="hidden text-xs text-center text-yellow-500 font-mono animate-pulse">
                        Processing Data...
                    </div>
                </div>

                <!-- Image Processing -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Image Processing</h2>

                    <div class="space-y-2">
                        <select id="select-img-op"
                            class="w-full bg-neutral-800 border border-neutral-700 text-white rounded p-2 outline-none focus:border-sky-500 text-xs">
                            <option value="" disabled selected>Select Operation...</option>
                            <optgroup label="Enhancement">
                                <option value="clahe">1. T1-Optimized CLAHE (Adaptive)</option>
                                <option value="hist_eq">2. Global Histogram Equalization</option>
                                <option value="gamma_bright">3. Gamma Correction (Brighten)</option>
                                <option value="gamma_dark">4. Gamma Correction (Darken)</option>
                                <option value="sigmoid">5. Sigmoid Contrast Stretch</option>
                                <option value="rescale">6. Rescale Intensity (Min/Max Norm)</option>
                            </optgroup>
                            <optgroup label="Filtering / Denoising">
                                <option value="unsharp">7. Unsharp Masking (Sharpen Edges)</option>
                                <option value="tv_denoise">8. Total Variation Denoising (Preserve Edges)</option>
                                <option value="gaussian">9. Gaussian Smoothing (Reduce Noise)</option>
                                <option value="median_3d">10. 3D Median Filter (Edge-Preserving Noise)</option>
                                <option value="morph_erosion">11. Morphological Erosion (Skull-Strip Proxy)</option>
                            </optgroup>
                            <optgroup label="Bias Field Correction">
                                <option value="n4_bias">12. N4 Bias Field Correction (Requires SimpleITK)</option>
                            </optgroup>
                        </select>

                        <button id="btn-run-op"
                            class="w-full py-2 px-3 rounded text-white font-medium bg-indigo-700 hover:bg-indigo-600 transition-colors border border-indigo-800">
                            Run Operation
                        </button>
                        <div id="op-status" class="text-xs text-neutral-500 font-mono hidden"></div>
                    </div>
                </div>

                <!-- Manual Tools -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Manual Tools</h2>
                    <div class="flex items-center gap-2 bg-neutral-800 p-2 rounded flex-wrap">
                        <label class="cursor-pointer text-xs text-neutral-300 flex items-center gap-1">
                            <input type="radio" name="tool" value="nav" checked class="accent-sky-500">
                            Nav
                        </label>
                        <label class="cursor-pointer text-xs text-neutral-300 flex items-center gap-1">
                            <input type="radio" name="tool" value="brush" class="accent-emerald-500">
                            Brush
                        </label>
                        <label class="cursor-pointer text-xs text-neutral-300 flex items-center gap-1">
                            <input type="radio" name="tool" value="erase" class="accent-red-500">
                            Eraser
                        </label>
                        <label class="cursor-pointer text-xs text-neutral-300 flex items-center gap-1">
                            <input type="radio" name="tool" value="measure" class="accent-yellow-500">
                            üìè Measure
                        </label>
                    </div>

                    <div class="space-y-1">
                        <div class="flex justify-between text-neutral-300">
                            <label>Size (px)</label>
                            <span id="val-brush-size" class="font-mono text-sky-400">5</span>
                        </div>
                        <input type="range" id="input-brush-size" min="1" max="50" value="5" class="w-full">
                    </div>

                    <!-- Undo/Redo -->
                    <div class="flex gap-2 items-center">
                        <button id="btn-undo"
                            class="undo-redo-btn py-1 px-2 rounded text-white font-medium bg-neutral-700 hover:bg-neutral-600 transition-colors"
                            disabled title="Undo (Ctrl+Z)">‚Ü∂</button>
                        <button id="btn-redo"
                            class="undo-redo-btn py-1 px-2 rounded text-white font-medium bg-neutral-700 hover:bg-neutral-600 transition-colors"
                            disabled title="Redo (Ctrl+Y)">‚Ü∑</button>
                        <span class="text-xs text-neutral-500 flex-1">Undo / Redo</span>
                        <button id="btn-clear-measurements"
                            class="py-1 px-2 rounded text-xs text-neutral-300 bg-neutral-800 hover:bg-neutral-700 transition-colors"
                            title="Clear all measurements">Clear üìè</button>
                    </div>
                </div>


                <!-- Thresholding & Segmentation -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Thresholding & Seg</h2>

                    <div class="space-y-2">
                        <select id="select-seg-op"
                            class="w-full bg-neutral-800 border border-neutral-700 text-white rounded p-2 outline-none focus:border-sky-500 text-xs">
                            <option value="" disabled selected>Select Operation...</option>
                            <optgroup label="Manual">
                                <option value="binary">1. Binary Threshold (Manual)</option>
                                <option value="binary_inv">2. Binary Inverted (Manual)</option>
                                <option value="truncate">3. Truncate (Cap Values)</option>
                                <option value="range_pass">4. Range Pass (Mid-tones)</option>
                            </optgroup>
                            <optgroup label="Automated (Global)">
                                <option value="otsu">5. Otsu's Method (2 Classes)</option>
                                <option value="li">6. Li's Method (2 Classes)</option>
                                <option value="multi_otsu">7. Multi-Otsu (3 Classes)</option>
                            </optgroup>
                            <optgroup label="Automated (Local)">
                                <option value="local_adaptive">8. Local Adaptive (Gaussian)</option>
                            </optgroup>
                        </select>

                        <!-- Dynamic Params -->
                        <div id="seg-params" class="hidden grid grid-cols-2 gap-2">
                            <input id="input-seg-p1" type="number" placeholder="Thresh"
                                class="bg-neutral-800 border border-neutral-700 text-white rounded p-1 text-xs w-full">
                            <input id="input-seg-p2" type="number" placeholder="Max"
                                class="bg-neutral-800 border border-neutral-700 text-white rounded p-1 text-xs w-full">
                        </div>

                        <button id="btn-run-seg"
                            class="w-full py-2 px-3 rounded text-white font-medium bg-teal-700 hover:bg-teal-600 transition-colors border border-teal-800">
                            Run Seg / Threshold
                        </button>
                    </div>
                </div>

                <!-- Mask Controls -->
                <div id="group-mask" class="space-y-3 opacity-50 pointer-events-none transition-opacity">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider flex justify-between">
                        Mask Overlay
                        <input type="checkbox" id="check-mask" checked class="w-4 h-4 accent-sky-500">
                    </h2>

                    <div class="space-y-1">
                        <div class="flex justify-between text-neutral-300">
                            <label>Opacity</label>
                            <span id="val-mask-opacity" class="font-mono text-sky-400">0.5</span>
                        </div>
                        <input type="range" id="input-mask-opacity" min="0" max="1" step="0.1" value="0.5"
                            class="w-full">
                    </div>
                </div>

                <!-- Window/Level -->
                <div class="space-y-4">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Window / Level</h2>

                    <div class="space-y-1">
                        <div class="flex justify-between text-neutral-300">
                            <label>Contrast (Width)</label>
                            <span id="val-ww" class="font-mono text-sky-400">400</span>
                        </div>
                        <input type="range" id="input-ww" min="1" max="2000" value="400" class="w-full">
                    </div>

                    <div class="space-y-1">
                        <div class="flex justify-between text-neutral-300">
                            <label>Brightness (Center)</label>
                            <span id="val-wc" class="font-mono text-sky-400">200</span>
                        </div>
                        <input type="range" id="input-wc" min="0" max="1000" value="200" class="w-full">
                    </div>
                </div>

                <!-- Appearance -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Appearance</h2>

                    <div class="flex items-center justify-between">
                        <span class="text-neutral-300">Show Crosshairs</span>
                        <input type="checkbox" id="check-crosshair" checked class="w-4 h-4 accent-sky-500">
                    </div>

                    <div class="flex items-center justify-between">
                        <span class="text-neutral-300">Invert</span>
                        <input type="checkbox" id="check-invert" class="w-4 h-4 accent-sky-500">
                    </div>

                    <div class="space-y-1 pt-2">
                        <label class="text-neutral-300 block mb-1">Colormap</label>
                        <select id="select-colormap"
                            class="w-full bg-neutral-800 border border-neutral-700 text-white rounded p-2 outline-none focus:border-sky-500">
                            <option value="grayscale">Grayscale</option>
                            <option value="hot">Hot Metal</option>
                            <option value="cool">Cool Blue</option>
                            <option value="rainbow">Rainbow</option>
                        </select>
                    </div>
                    <div class="space-y-1 pt-2">
                        <label class="text-neutral-300 block mb-1">Dual View Opacity</label>
                        <div class="flex items-center gap-2">
                            <input id="input-dual-opacity" type="range" min="0" max="1" step="0.05" value="0.5"
                                class="flex-1">
                            <span id="val-dual-opacity" class="w-10 text-right font-mono text-sky-400">0.5</span>
                        </div>
                        <p class="text-xs text-neutral-500 mt-1">Blend opacity for the secondary MRI overlay.</p>
                    </div>
                    <div class="space-y-1 pt-2">
                        <label class="text-neutral-300 block mb-1">Dual View Mode</label>
                        <select id="select-dual-mode"
                            class="w-full bg-neutral-800 border border-neutral-700 text-white rounded p-2 outline-none focus:border-sky-500 text-xs">
                            <option value="blend">Blend (Overlay)</option>
                            <option value="difference">Difference Map</option>
                            <option value="split">Side-by-side Split</option>
                        </select>
                        <p class="text-xs text-neutral-500 mt-1">Choose how the secondary MRI is visualized.</p>
                    </div>
                    <div class="space-y-1 pt-2">
                        <label class="text-neutral-300 block mb-1">Render Quality</label>
                        <div class="flex items-center gap-2">
                            <input id="input-render-quality" type="range" min="1" max="100" step="1" value="70"
                                class="flex-1">
                            <span id="val-render-quality" class="w-10 text-right font-mono text-sky-400">70</span>
                        </div>
                        <p class="text-xs text-neutral-500 mt-1">Higher = better visuals, lower = faster performance.
                        </p>
                    </div>
                </div>

                <!-- Export -->
                <div class="space-y-3">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Export</h2>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="btn-export-mask"
                            class="py-2 px-3 rounded text-white font-medium bg-emerald-700 hover:bg-emerald-600 transition-colors text-xs">
                            Export Mask (NIfTI)
                        </button>
                        <button id="btn-export-slice"
                            class="py-2 px-3 rounded text-white font-medium bg-cyan-700 hover:bg-cyan-600 transition-colors text-xs">
                            Export Slice (PNG)
                        </button>
                    </div>
                    <button id="btn-screenshot"
                        class="w-full py-2 px-3 rounded text-white font-medium screenshot-btn transition-colors text-xs">
                        üì∏ Screenshot All Viewports
                    </button>
                    <p class="text-xs text-neutral-500">Keyboard: <span class="text-sky-400">?</span> for shortcuts,
                        <span class="text-sky-400">Tab</span> for sidebar
                    </p>
                </div>


                <!-- Info -->
                <div class="p-3 bg-neutral-800 rounded font-mono text-xs text-neutral-400 space-y-1">
                    <div class="flex justify-between">
                        <span>Dimensions:</span>
                        <span id="info-dims" class="text-white">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Voxel Pos:</span>
                        <span id="info-pos" class="text-white">[0, 0, 0]</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Intensity:</span>
                        <span id="info-val" class="text-white">0</span>
                    </div>
                </div>

                <!-- Histogram -->
                <div class="space-y-2">
                    <h2 class="text-xs font-bold text-neutral-400 uppercase tracking-wider">Intensity Histogram</h2>
                    <div class="histogram-container relative">
                        <canvas id="histogram-canvas" class="histogram-canvas"></canvas>
                        <div class="histogram-info">
                            <span id="hist-min">Min: -</span>
                            <span id="hist-cursor" class="text-sky-400">-</span>
                            <span id="hist-max">Max: -</span>
                        </div>
                    </div>
                    <p class="text-xs text-neutral-500">Click to set window center, drag for width</p>
                </div>

                <button id="btn-reset"
                    class="w-full py-2 border border-neutral-600 text-neutral-400 rounded hover:bg-neutral-800 transition-colors">
                    Reset Views
                </button>
            </div>
        </div>

        <!-- Main Grid -->
        <!-- Main Grid -->
        <div id="main-grid-container" class="flex-1 grid grid-cols-2 grid-rows-2 gap-0.5 bg-neutral-900 p-0.5">

            <!-- Axial -->
            <div id="view-axial" class="viewport active" data-axis="axial">
                <div class="overlay-text flex items-center">
                    <span class="vp-label">AXIAL</span>
                    <button class="view-control-btn btn-fullscreen" title="Toggle Fullscreen"
                        aria-label="Toggle fullscreen axial view">‚õ∂</button>
                </div>
                <div class="flex-1 relative flex items-center justify-center w-full h-full overflow-hidden">
                    <canvas role="img" aria-label="Axial view canvas" tabindex="0"></canvas>
                </div>
            </div>

            <!-- Coronal -->
            <div id="view-coronal" class="viewport" data-axis="coronal">
                <div class="overlay-text flex items-center">
                    <span class="vp-label">CORONAL</span>
                    <button class="view-control-btn btn-fullscreen" title="Toggle Fullscreen"
                        aria-label="Toggle fullscreen coronal view">‚õ∂</button>
                </div>
                <div class="flex-1 relative flex items-center justify-center w-full h-full overflow-hidden">
                    <canvas role="img" aria-label="Coronal view canvas" tabindex="0"></canvas>
                </div>
            </div>

            <!-- Sagittal -->
            <div id="view-sagittal" class="viewport" data-axis="sagittal">
                <div class="overlay-text flex items-center">
                    <span class="vp-label">SAGITTAL</span>
                    <button class="view-control-btn btn-fullscreen" title="Toggle Fullscreen"
                        aria-label="Toggle fullscreen sagittal view">‚õ∂</button>
                </div>
                <div class="flex-1 relative flex items-center justify-center w-full h-full overflow-hidden">
                    <canvas role="img" aria-label="Sagittal view canvas" tabindex="0"></canvas>
                </div>
            </div>

            <!-- 3D -->
            <div id="view-3d" class="viewport" data-axis="3d">
                <div class="overlay-text flex items-center">
                    <span class="vp-label text-yellow-500">3D PROJECTION</span>
                    <button class="view-control-btn btn-fullscreen" title="Toggle Fullscreen"
                        aria-label="Toggle fullscreen 3D view">‚õ∂</button>
                </div>
                <div class="flex-1 relative flex items-center justify-center w-full h-full overflow-hidden bg-black">
                    <canvas id="canvas-3d" role="img" aria-label="3D projection canvas" tabindex="0"></canvas>
                    <div id="3d-placeholder-text" class="absolute text-center pointer-events-none">
                        <div
                            class="w-16 h-16 rounded-full border-2 border-neutral-800 border-t-neutral-600 animate-spin mx-auto mb-2">
                        </div>
                        <span class="text-neutral-600 text-xs">Load Data to Render 3D</span>
                    </div>
                    <div id="vtk-loading" class="lazy-loading-overlay hidden">
                        <div class="lazy-spinner"></div>
                        <div>Loading VTK.js...</div>
                        <div class="progress-bar">
                            <div id="vtk-progress" class="progress-fill"></div>
                        </div>
                    </div>
                    <div id="3d-rendering" class="lazy-loading-overlay hidden">
                        <div class="lazy-spinner"></div>
                        <div>Rendering 3D...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * NIfTI PARSER
         */
        class NiftiParser {
            static parseHeader(arrayBuffer) {
                const dataView = new DataView(arrayBuffer);

                // Basic check
                if (arrayBuffer.byteLength < 348) throw new Error("File too small");

                const headerSizeLittle = dataView.getInt32(0, true);
                const headerSizeBig = dataView.getInt32(0, false);
                let isLittleEndian = true;

                if (headerSizeLittle === 348 || headerSizeLittle === 540) {
                    isLittleEndian = true;
                } else if (headerSizeBig === 348 || headerSizeBig === 540) {
                    isLittleEndian = false;
                } else {
                    throw new Error('Invalid NIfTI header');
                }

                const dims = [];
                for (let i = 0; i < 8; i++) {
                    dims.push(dataView.getInt16(40 + i * 2, isLittleEndian));
                }

                const datatype = dataView.getInt16(70, isLittleEndian);
                const vox_offset = dataView.getFloat32(108, isLittleEndian);
                const scl_slope = dataView.getFloat32(112, isLittleEndian);
                const scl_inter = dataView.getFloat32(116, isLittleEndian);

                // Read pixdim (voxel spacing) at byte offset 76 (8 floats)
                const pixdim = [];
                for (let i = 0; i < 8; i++) {
                    pixdim.push(dataView.getFloat32(76 + i * 4, isLittleEndian));
                }

                return {
                    dims: { x: dims[1], y: dims[2], z: dims[3] || 1 },
                    datatype,
                    vox_offset,
                    scl_slope: scl_slope === 0 ? 1 : scl_slope,
                    scl_inter,
                    isLittleEndian,
                    voxelDims: { x: pixdim[1] || 1.0, y: pixdim[2] || 1.0, z: pixdim[3] || 1.0 }
                };
            }

            static readData(header, arrayBuffer) {
                const offset = Math.floor(header.vox_offset);
                const size = header.dims.x * header.dims.y * header.dims.z;
                let typedArray;

                switch (header.datatype) {
                    case 2: typedArray = new Uint8Array(arrayBuffer, offset, size); break;
                    case 4: typedArray = new Int16Array(arrayBuffer, offset, size); break;
                    case 8: typedArray = new Int32Array(arrayBuffer, offset, size); break;
                    case 16: typedArray = new Float32Array(arrayBuffer, offset, size); break;
                    case 64: typedArray = new Float64Array(arrayBuffer, offset, size); break;
                    case 512: typedArray = new Uint16Array(arrayBuffer, offset, size); break;
                    default: throw new Error(`Unsupported datatype: ${header.datatype}`);
                }

                // Convert to Float32 for internal processing and apply scaling if needed
                const data = new Float32Array(size);
                let min = Infinity;
                let max = -Infinity;

                const slope = header.scl_slope;
                const inter = header.scl_inter;

                for (let i = 0; i < size; i++) {
                    let val = typedArray[i] * slope + inter;
                    data[i] = val;
                    if (val < min) min = val;
                    if (val > max) max = val;
                }

                return { data, min, max };
            }
        }

        /**
         * APP STATE
         */
        const state = {
            volume: null, // { data: Float32Array, dims: {x,y,z}, min, max }
            secondaryVolume: null,
            mask: null,   // { data: Float32Array, dims: {x,y,z} }
            crosshair: { x: 0, y: 0, z: 0 },
            activeAxis: 'axial',
            settings: {
                windowWidth: 400,
                windowCenter: 200,
                showCrosshair: true,
                invert: false,
                colorMap: 'grayscale',
                showMask: true,
                maskOpacity: 0.5,
                renderQuality: 70
                , dualViewEnabled: false,
                dualViewOpacity: 0.5,
                dualMode: 'blend' // 'blend' | 'difference'
            },
            ui: {
                rotate3D: { x: 0, y: 0 },
                // Pan/Zoom support per viewport
                viewports: {
                    axial: { zoom: 1, pan: { x: 0, y: 0 } },
                    sagittal: { zoom: 1, pan: { x: 0, y: 0 } },
                    coronal: { zoom: 1, pan: { x: 0, y: 0 } }
                },
                tool: 'nav', // 'nav', 'brush', 'erase', 'measure'
                brushSize: 5,
                isPainting: false,
                // Measurement state
                measureStart: null, // { axis, x, y, voxel: {x,y,z} }
                measurements: []    // [{ axis, start, end, distance, label }]
            }
            ,
            labelMap: {} // mapping integer label -> name
        };

        /**
         * HISTORY MANAGER (Undo/Redo)
         */
        class HistoryManager {
            constructor(maxSize = 15) {
                this.stack = [];
                this.index = -1;
                this.maxSize = maxSize;
            }

            // Create a snapshot of current mask state
            createSnapshot() {
                if (!state.mask) return null;
                return {
                    maskData: new Float32Array(state.mask.data),
                    dims: { ...state.mask.dims }
                };
            }

            // Push current state before making changes
            push() {
                const snapshot = this.createSnapshot();
                if (!snapshot) return;

                // Remove any redo states after current index
                if (this.index < this.stack.length - 1) {
                    this.stack = this.stack.slice(0, this.index + 1);
                }

                this.stack.push(snapshot);

                // Limit stack size
                if (this.stack.length > this.maxSize) {
                    this.stack.shift();
                } else {
                    this.index++;
                }

                this.updateButtons();
            }

            undo() {
                if (!this.canUndo()) return false;

                // Save current state for redo if we're at the end
                if (this.index === this.stack.length - 1) {
                    const currentSnapshot = this.createSnapshot();
                    if (currentSnapshot) {
                        this.stack.push(currentSnapshot);
                    }
                }

                const snapshot = this.stack[this.index];
                this.index--;
                this.restoreSnapshot(snapshot);
                this.updateButtons();
                return true;
            }

            redo() {
                if (!this.canRedo()) return false;

                this.index++;
                const snapshot = this.stack[this.index + 1];
                if (snapshot) {
                    this.restoreSnapshot(snapshot);
                }
                this.updateButtons();
                return true;
            }

            restoreSnapshot(snapshot) {
                if (!snapshot) return;
                state.mask = {
                    dims: snapshot.dims,
                    data: new Float32Array(snapshot.maskData)
                };
                renderAll();
                try { render3D(); } catch (e) { }
            }

            canUndo() { return this.index >= 0; }
            canRedo() { return this.index < this.stack.length - 2; }

            updateButtons() {
                const undoBtn = document.getElementById('btn-undo');
                const redoBtn = document.getElementById('btn-redo');
                if (undoBtn) undoBtn.disabled = !this.canUndo();
                if (redoBtn) redoBtn.disabled = !this.canRedo();
            }

            clear() {
                this.stack = [];
                this.index = -1;
                this.updateButtons();
            }
        }

        const historyManager = new HistoryManager();


        /**
         * LAZY LOADING FOR HEAVY LIBRARIES
         */
        const LibraryLoader = {
            vtk: null,
            vtkLoading: false,
            vtkPromise: null,

            async loadVTK() {
                if (this.vtk) return this.vtk;
                if (this.vtkLoading) return this.vtkPromise;

                this.vtkLoading = true;

                const loadingEl = document.getElementById('vtk-loading');
                const progressEl = document.getElementById('vtk-progress');
                if (loadingEl) loadingEl.classList.remove('hidden');

                const loader = this;

                // Helper: fetch & inject as before (streaming fallback)
                const fetchAndInject = async () => {
                    const response = await fetch('vtk.js', { mode: 'cors' });
                    if (!response.ok) throw new Error('Failed to fetch VTK.js');

                    const total = parseInt(response.headers.get('content-length') || '0', 10);
                    const reader = response.body.getReader();
                    const chunks = [];

                    let received = 0;
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        received += value.length;

                        if (total && progressEl) {
                            const percent = Math.round((received / total) * 100);
                            progressEl.style.width = percent + '%';
                        }
                    }

                    const allChunks = new Uint8Array(received);
                    let position = 0;
                    for (const chunk of chunks) {
                        allChunks.set(chunk, position);
                        position += chunk.length;
                    }

                    const script = document.createElement('script');
                    script.textContent = new TextDecoder('utf-8').decode(allChunks);
                    document.head.appendChild(script);

                    if (typeof vtk === 'undefined') {
                        throw new Error('VTK.js failed to initialize after fetch');
                    }
                    return vtk;
                };

                this.vtkPromise = new Promise((resolve, reject) => {
                    // First attempt: dynamic script tag (works for file:// in many browsers)
                    try {
                        const s = document.createElement('script');
                        s.src = 'vtk.js';
                        s.async = true;
                        s.onload = () => {
                            if (typeof vtk !== 'undefined') {
                                loader.vtk = vtk;
                                if (loadingEl) loadingEl.classList.add('hidden');
                                document.getElementById('3d-rendering')?.classList.add('hidden');
                                loader.vtkLoading = false;
                                resolve(vtk);
                            } else {
                                // Not initialized by script tag; try fetch fallback
                                fetchAndInject().then((v) => {
                                    loader.vtk = v;
                                    if (loadingEl) loadingEl.classList.add('hidden');
                                    document.getElementById('3d-rendering')?.classList.add('hidden');
                                    loader.vtkLoading = false;
                                    resolve(v);
                                }).catch(err => {
                                    console.error('Failed to load VTK.js via fetch fallback:', err);
                                    if (loadingEl) loadingEl.innerHTML = '<div class="text-red-400">Failed to load VTK.js</div>';
                                    loader.vtkLoading = false;
                                    reject(err);
                                });
                            }
                        };
                        s.onerror = () => {
                            // Script tag failed (often blocked under strict CSP); try fetch fallback
                            fetchAndInject().then((v) => {
                                loader.vtk = v;
                                if (loadingEl) loadingEl.classList.add('hidden');
                                document.getElementById('3d-rendering')?.classList.add('hidden');
                                loader.vtkLoading = false;
                                resolve(v);
                            }).catch(err => {
                                console.error('Failed to load VTK.js via fetch fallback:', err);
                                if (loadingEl) loadingEl.innerHTML = '<div class="text-red-400">Failed to load VTK.js</div>';
                                loader.vtkLoading = false;
                                reject(err);
                            });
                        };

                        document.head.appendChild(s);
                        // If neither onload nor onerror fire within a timeout, attempt fetch fallback
                        setTimeout(() => {
                            if (!loader.vtk && loader.vtkLoading) {
                                // try fetch fallback as last resort
                                fetchAndInject().then((v) => {
                                    loader.vtk = v;
                                    if (loadingEl) loadingEl.classList.add('hidden');
                                    document.getElementById('3d-rendering')?.classList.add('hidden');
                                    loader.vtkLoading = false;
                                    resolve(v);
                                }).catch(err => {
                                    console.error('Failed to load VTK.js after timeout fallback:', err);
                                    if (loadingEl) loadingEl.innerHTML = '<div class="text-red-400">Failed to load VTK.js</div>';
                                    loader.vtkLoading = false;
                                    reject(err);
                                });
                            }
                        }, 5000);
                    } catch (err) {
                        // If anything throws, fallback to fetch method
                        fetchAndInject().then((v) => {
                            loader.vtk = v;
                            if (loadingEl) loadingEl.classList.add('hidden');
                            document.getElementById('3d-rendering')?.classList.add('hidden');
                            loader.vtkLoading = false;
                            resolve(v);
                        }).catch(e => {
                            console.error('Failed to load VTK.js:', e);
                            if (loadingEl) loadingEl.innerHTML = '<div class="text-red-400">Failed to load VTK.js</div>';
                            loader.vtkLoading = false;
                            reject(e);
                        });
                    }
                });

                return this.vtkPromise;
            }
        };

        /**
         * IMAGE PROCESSING ALGORITHMS
         */
        class ImageProcessor {
            // Helper: Clone data to avoid mutating original until success
            static cloneVolume(volume) {
                return {
                    ...volume,
                    data: new Float32Array(volume.data)
                };
            }

            // 1. CLAHE (Simplified 2D-slice based or Global with local window)
            static applyCLAHE(volume, clipLimit = 2.0) {
                // Robust Global Histogram Equalization with clamping (Simplified CLAHE)
                const data = volume.data;
                const len = data.length;

                // 1. Min/Max
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < len; i++) {
                    if (data[i] < min) min = data[i];
                    if (data[i] > max) max = data[i];
                }
                const range = max - min;
                if (range <= 0) return volume; // No contrast

                // 2. Histogram
                const bins = 2048;
                const hist = new Uint32Array(bins);
                for (let i = 0; i < len; i++) {
                    const idx = Math.floor(((data[i] - min) / range) * (bins - 1));
                    hist[idx]++;
                }

                // 3. Clip Histogram (Contrast Limiting)
                const average = len / bins;
                const limit = clipLimit * average;
                let excess = 0;
                for (let i = 0; i < bins; i++) {
                    if (hist[i] > limit) {
                        excess += hist[i] - limit;
                        hist[i] = limit;
                    }
                }
                // Redistribute excess
                const incr = excess / bins;
                for (let i = 0; i < bins; i++) hist[i] += incr;

                // 4. CDF
                const cdf = new Float32Array(bins);
                let acc = 0;
                for (let i = 0; i < bins; i++) {
                    acc += hist[i];
                    cdf[i] = acc / len;
                }

                // 5. Map
                for (let i = 0; i < len; i++) {
                    const idx = Math.floor(((data[i] - min) / range) * (bins - 1));
                    data[i] = min + cdf[idx] * range;
                }

                return volume;
            }

            static applyHistEq(volume) {
                return this.applyCLAHE(volume, Infinity); // Global HE = CLAHE with infinite clip
            }

            static applyGamma(volume, gamma) {
                const data = volume.data;
                const len = data.length;
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < len; i++) {
                    if (data[i] < min) min = data[i];
                    if (data[i] > max) max = data[i];
                }
                const range = max - min;
                if (range <= 0) return volume;

                for (let i = 0; i < len; i++) {
                    let norm = (data[i] - min) / range;
                    if (norm < 0) norm = 0;
                    if (norm > 1) norm = 1;
                    data[i] = min + Math.pow(norm, gamma) * range;
                }
                return volume;
            }

            static applySigmoid(volume, gain = 10, cutoff = 0.5) {
                const data = volume.data;
                const len = data.length;
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < len; i++) {
                    if (data[i] < min) min = data[i];
                    if (data[i] > max) max = data[i];
                }
                const range = max - min;
                if (range <= 0) return volume;

                for (let i = 0; i < len; i++) {
                    const norm = (data[i] - min) / range;
                    const val = 1 / (1 + Math.exp(-gain * (norm - cutoff)));
                    data[i] = min + val * range;
                }
                return volume;
            }

            static applyRescale(volume) {
                // Rescale to 0..1000 standard range
                const data = volume.data;
                const len = data.length;
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < len; i++) {
                    if (data[i] < min) min = data[i];
                    if (data[i] > max) max = data[i];
                }
                const range = max - min;
                if (range <= 0) return volume;

                for (let i = 0; i < len; i++) {
                    data[i] = ((data[i] - min) / range) * 1000;
                }
                volume.min = 0; volume.max = 1000;
                return volume;
            }

            static applyGaussian(volume, sigma = 1.0) {
                // Simple 3D stencil approximation for speed
                const { dims, data } = volume;
                const w = dims.x, h = dims.y, d = dims.z;
                const out = new Float32Array(data.length);
                const strideXY = w * h;

                for (let z = 1; z < d - 1; z++) {
                    for (let y = 1; y < h - 1; y++) {
                        let rowOffset = y * w + z * strideXY;
                        for (let x = 1; x < w - 1; x++) {
                            const idx = x + rowOffset;
                            // 3D Cross smoothing
                            const sum = data[idx] * 4 +
                                data[idx - 1] + data[idx + 1] +
                                data[idx - w] + data[idx + w] +
                                data[idx - strideXY] + data[idx + strideXY];
                            out[idx] = sum / 10.0;
                        }
                    }
                }
                volume.data = out;
                return volume;
            }

            static applyMedian3D(volume) {
                const { dims, data } = volume;
                const w = dims.x, h = dims.y, d = dims.z;
                const out = new Float32Array(data.length);
                const strideXY = w * h;
                const neighborVals = new Float32Array(27);

                for (let z = 1; z < d - 1; z++) {
                    for (let y = 1; y < h - 1; y++) {
                        let rowOffset = y * w + z * strideXY;
                        for (let x = 1; x < w - 1; x++) {
                            const idx = x + rowOffset;
                            let c = 0;
                            // 3x3x3 block
                            for (let kz = -1; kz <= 1; kz++) {
                                for (let ky = -1; ky <= 1; ky++) {
                                    for (let kx = -1; kx <= 1; kx++) {
                                        neighborVals[c++] = data[idx + kx + ky * w + kz * strideXY];
                                    }
                                }
                            }
                            neighborVals.sort();
                            out[idx] = neighborVals[13]; // Median of 27
                        }
                    }
                }
                volume.data = out;
                return volume;
            }

            static applyUnsharp(volume, amount = 1.5) {
                // I - blurred
                const copy = ImageProcessor.cloneVolume(volume);
                const blurred = ImageProcessor.applyGaussian(copy);

                const data = volume.data;
                const bData = blurred.data;
                const len = data.length;

                for (let i = 0; i < len; i++) {
                    const diff = data[i] - bData[i];
                    data[i] = data[i] + diff * amount;
                }
                return volume;
            }

            static applyMorphErosion(volume) {
                const { dims, data } = volume;
                const w = dims.x, h = dims.y, d = dims.z;
                const out = new Float32Array(data.length);
                const strideXY = w * h;

                // Min filter
                for (let z = 1; z < d - 1; z++) {
                    for (let y = 1; y < h - 1; y++) {
                        let rowOffset = y * w + z * strideXY;
                        for (let x = 1; x < w - 1; x++) {
                            const idx = x + rowOffset;
                            let minV = Infinity;
                            // 3x3x3 cross
                            const val = data[idx];
                            if (val < minV) minV = val;
                            if (data[idx - 1] < minV) minV = data[idx - 1];
                            if (data[idx + 1] < minV) minV = data[idx + 1];
                            if (data[idx - w] < minV) minV = data[idx - w];
                            if (data[idx + w] < minV) minV = data[idx + w];
                            if (data[idx - strideXY] < minV) minV = data[idx - strideXY];
                            if (data[idx + strideXY] < minV) minV = data[idx + strideXY];
                            out[idx] = minV;
                        }
                    }
                }
                volume.data = out;
                return volume;
            }

            static applyTVDenoise(volume, iter = 5) {
                // Rudimentary Total Variation
                const { dims, data } = volume;
                const w = dims.x, h = dims.y, d = dims.z;
                const strideXY = w * h;
                const lambda = 0.1; // smoothing factor

                for (let it = 0; it < iter; it++) {
                    for (let z = 1; z < d - 1; z++) {
                        for (let y = 1; y < h - 1; y++) {
                            let rowOffset = y * w + z * strideXY;
                            for (let x = 1; x < w - 1; x++) {
                                const idx = x + rowOffset;
                                const u = data[idx];
                                const u_x = data[idx + 1]; const u_X = data[idx - 1];
                                const u_y = data[idx + w]; const u_Y = data[idx - w];
                                const u_z = data[idx + strideXY]; const u_Z = data[idx - strideXY];

                                // Forward/Backward gradients
                                const avg = (u_x + u_X + u_y + u_Y + u_z + u_Z) / 6.0;
                                data[idx] = u + lambda * (avg - u);
                            }
                        }
                    }
                }
                return volume;
            }

            static applyN4Bias(volume) {
                // Very simplified correction
                const input = volume.data;
                const len = input.length;

                // 1. Log transform 
                const logData = new Float32Array(len);
                for (let i = 0; i < len; i++) {
                    logData[i] = Math.log(Math.max(1, input[i]));
                }

                // 2. Heavy gaussian smoothing
                const biasVol = { dims: volume.dims, data: logData };
                for (let k = 0; k < 4; k++) ImageProcessor.applyGaussian(biasVol);

                // 3. Subtract bias
                const vals = volume.data;
                for (let i = 0; i < len; i++) {
                    const logBias = logData[i];
                    const val = Math.exp(Math.log(Math.max(1, vals[i])) - logBias + 4.5);
                    vals[i] = val;
                }
                return volume;
            }
        }

        /**
         * DOM ELEMENTS
         */
        const els = {
            viewports: {
                axial: document.getElementById('view-axial'),
                coronal: document.getElementById('view-coronal'),
                sagittal: document.getElementById('view-sagittal'),
                v3d: document.getElementById('canvas-3d')
            },
            inputs: {
                ww: document.getElementById('input-ww'),
                wc: document.getElementById('input-wc'),
                crosshair: document.getElementById('check-crosshair'),
                invert: document.getElementById('check-invert'),
                colormap: document.getElementById('select-colormap'),
                btnGenerate: document.getElementById('btn-generate'),
                btnLoadMri: document.getElementById('btn-load-mri'),
                btnLoadMri2: document.getElementById('btn-load-mri2'),
                btnLoadMask: document.getElementById('btn-load-mask'),
                fileMri: document.getElementById('input-file-mri'),
                fileMri2: document.getElementById('input-file-mri2'),
                fileMask: document.getElementById('input-file-mask'),
                fileLabelConfig: document.getElementById('input-file-label-config'),
                btnLoadLabelConfig: document.getElementById('btn-load-label-config'),
                btnSaveLabelConfig: document.getElementById('btn-save-label-config'),
                btnReset: document.getElementById('btn-reset'),
                maskCheck: document.getElementById('check-mask'),
                maskOpacity: document.getElementById('input-mask-opacity'),
                dualCheck: document.getElementById('check-dual-view'),
                dualOpacity: document.getElementById('input-dual-opacity'),
                dualMode: document.getElementById('select-dual-mode'),
                opSelect: document.getElementById('select-img-op'),
                btnRunOp: document.getElementById('btn-run-op'),
                opStatus: document.getElementById('op-status')
            },
            labels: {
                ww: document.getElementById('val-ww'),
                wc: document.getElementById('val-wc'),
                maskOpacity: document.getElementById('val-mask-opacity'),
                dims: document.getElementById('info-dims'),
                pos: document.getElementById('info-pos'),
                val: document.getElementById('info-val'),
                loading: document.getElementById('loading-indicator'),
                maskGroup: document.getElementById('group-mask'),
                text3d: document.getElementById('3d-placeholder-text')
            }
        };

        // Extra refs for Seg
        els.inputs.segOp = document.getElementById('select-seg-op');
        els.inputs.segP1 = document.getElementById('input-seg-p1');
        els.inputs.segP2 = document.getElementById('input-seg-p2');
        els.inputs.btnRunSeg = document.getElementById('btn-run-seg');
        els.inputs.segParams = document.getElementById('seg-params');

        /**
         * FILE I/O
         */
        async function loadFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        let buffer = e.target.result;
                        // Handle gzip
                        if (file.name.endsWith('.gz')) {
                            buffer = pako.inflate(new Uint8Array(buffer)).buffer;
                        }

                        const header = NiftiParser.parseHeader(buffer);
                        const result = NiftiParser.readData(header, buffer);
                        // Return data + dims + voxel dimensions + raw header for later use
                        resolve({ ...result, dims: header.dims, voxelDims: header.voxelDims, header });
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        async function handleMriLoad(file) {
            els.labels.loading.classList.remove('hidden');
            els.labels.loading.textContent = `Loading ${file.name}...`;

            try {
                const vol = await loadFile(file);
                state.volume = vol;

                // Reset View
                const d = vol.dims;
                state.crosshair = { x: Math.floor(d.x / 2), y: Math.floor(d.y / 2), z: Math.floor(d.z / 2) };
                resetViews();

                // Auto W/L
                state.settings.windowWidth = (vol.max - vol.min);
                state.settings.windowCenter = (vol.max + vol.min) / 2;

                // Update Sliders
                els.inputs.ww.max = (vol.max - vol.min) * 1.5;
                els.inputs.wc.max = vol.max;
                els.inputs.ww.value = state.settings.windowWidth;
                els.inputs.wc.value = state.settings.windowCenter;
                els.labels.ww.textContent = Math.round(state.settings.windowWidth);
                els.labels.wc.textContent = Math.round(state.settings.windowCenter);

                renderAll(false);
                els.labels.text3d.classList.add('hidden');
            } catch (err) {
                alert("Error loading MRI: " + err.message);
            } finally {
                els.labels.loading.classList.add('hidden');
            }
        }

        async function handleMri2Load(file) {
            els.labels.loading.classList.remove('hidden');
            els.labels.loading.textContent = `Loading secondary ${file.name}...`;
            try {
                const vol = await loadFile(file);
                // If primary exists, dims must match
                if (state.volume) {
                    const vd = state.volume.dims;
                    const sd = vol.dims;
                    if (vd.x !== sd.x || vd.y !== sd.y || vd.z !== sd.z) {
                        throw new Error(`Dimension mismatch: Primary ${vd.x}x${vd.y}x${vd.z} vs Secondary ${sd.x}x${sd.y}x${sd.z}`);
                    }
                }

                if (!state.volume) {
                    // If no primary exists, make this the primary volume
                    state.volume = vol;
                    state.secondaryVolume = null;
                    // Reset crosshair to center
                    const d = vol.dims;
                    state.crosshair = { x: Math.floor(d.x / 2), y: Math.floor(d.y / 2), z: Math.floor(d.z / 2) };
                } else {
                    state.secondaryVolume = vol;
                    // Enable dual-view automatically when a secondary is loaded
                    state.settings.dualViewEnabled = true;
                    if (els.inputs.dualCheck) els.inputs.dualCheck.checked = true;
                }

                renderAll(false);
            } catch (err) {
                alert("Error loading secondary MRI: " + err.message);
            } finally {
                els.labels.loading.classList.add('hidden');
            }
        }

        async function handleMaskLoad(file) {
            if (!state.volume) {
                alert("Load an MRI volume first.");
                return;
            }
            els.labels.loading.classList.remove('hidden');

            try {
                const mask = await loadFile(file);
                // Dim check
                const vd = state.volume.dims;
                const md = mask.dims;
                if (vd.x !== md.x || vd.y !== md.y || vd.z !== md.z) {
                    throw new Error(`Dimension mismatch: MRI ${vd.x}x${vd.y}x${vd.z} vs Mask ${md.x}x${md.y}x${md.z}`);
                }

                state.mask = mask;
                els.labels.maskGroup.classList.remove('opacity-50', 'pointer-events-none');
                populateLabelColorUI();
                renderAll(true);
            } catch (err) {
                alert(err.message);
            } finally {
                els.labels.loading.classList.add('hidden');
            }
        }

        // --- Label Config (JSON) Load / Save ---
        async function handleLabelConfigLoad(file) {
            try {
                const text = await file.text();
                const json = JSON.parse(text);
                // Normalize keys to integers
                const map = {};
                for (const k of Object.keys(json)) {
                    const ik = parseInt(k, 10);
                    const val = json[k];
                    // Support legacy format (string -> name) or new format (object with name and/or color)
                    if (typeof val === 'string') map[ik] = { name: val };
                    else if (typeof val === 'object' && val !== null) map[ik] = val;
                    else map[ik] = { name: String(val) };
                }
                state.labelMap = map;
                alert('Label configuration loaded. ' + Object.keys(map).length + ' entries.');
                populateLabelColorUI();
            } catch (err) {
                alert('Failed to load label config: ' + err.message);
            }
        }

        function handleLabelConfigSave() {
            try {
                const content = JSON.stringify(state.labelMap || {}, null, 2);
                const blob = new Blob([content], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'label_config.json';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            } catch (err) {
                alert('Failed to save label config: ' + err.message);
            }
        }

        function calculateVolumes() {
            if (!state.mask || !state.volume) {
                alert('Load both MRI and Mask first.');
                return;
            }

            const counts = new Map();
            const md = state.mask.dims;
            const data = state.mask.data;
            for (let i = 0; i < data.length; i++) {
                const v = Math.round(data[i]);
                if (v <= 0) continue;
                counts.set(v, (counts.get(v) || 0) + 1);
            }

            const voxel = state.volume.voxelDims || { x: 1, y: 1, z: 1 };
            const voxel_mm3 = voxel.x * voxel.y * voxel.z;

            const w = window.open('', '_blank');
            if (!w) {
                alert('Unable to open report window (pop-up blocked).');
                return;
            }

            const doc = w.document;
            doc.open();
            doc.write(`<!doctype html><html><head><meta charset="utf-8"><title>Volume Report</title><style>body{font-family:Arial;margin:10px}table{border-collapse:collapse}th,td{border:1px solid #ccc;padding:6px}</style></head><body><h2>Volumetric Analysis</h2></body></html>`);
            doc.close();

            const table = doc.createElement('table');
            const thead = doc.createElement('thead');
            const headerRow = doc.createElement('tr');
            ['Label', 'Name', 'Voxels', 'Volume (cm¬≥)'].forEach(h => {
                const th = doc.createElement('th');
                th.textContent = h;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = doc.createElement('tbody');
            for (const [label, cnt] of counts.entries()) {
                const vol_cm3 = (cnt * voxel_mm3) / 1000.0;
                let name = 'Label_' + label;
                if (state.labelMap && state.labelMap[label]) {
                    const entry = state.labelMap[label];
                    if (typeof entry === 'string') name = entry;
                    else if (typeof entry === 'object' && entry.name) name = entry.name;
                }

                const tr = doc.createElement('tr');
                const tdLabel = doc.createElement('td'); tdLabel.textContent = String(label); tr.appendChild(tdLabel);
                const tdName = doc.createElement('td'); tdName.textContent = name; tr.appendChild(tdName);
                const tdVox = doc.createElement('td'); tdVox.textContent = String(cnt); tr.appendChild(tdVox);
                const tdVol = doc.createElement('td'); tdVol.textContent = vol_cm3.toFixed(3); tr.appendChild(tdVol);
                tbody.appendChild(tr);
            }

            table.appendChild(tbody);
            doc.body.appendChild(table);
        }

        function resetViews() {
            state.ui.viewports.axial = { zoom: 1, pan: { x: 0, y: 0 } };
            state.ui.viewports.sagittal = { zoom: 1, pan: { x: 0, y: 0 } };
            state.ui.viewports.coronal = { zoom: 1, pan: { x: 0, y: 0 } };
            state.ui.rotate3D = { x: 0, y: 0 };
        }

        /**
         * VOLUME GENERATION (Fallback)
         */
        function generateSyntheticVolume(dims) {
            const size = dims.x * dims.y * dims.z;
            const data = new Float32Array(size);
            const cx = dims.x / 2;
            const cy = dims.y / 2;
            const cz = dims.z / 2;

            let min = Infinity;
            let max = -Infinity;

            for (let z = 0; z < dims.z; z++) {
                for (let y = 0; y < dims.y; y++) {
                    for (let x = 0; x < dims.x; x++) {
                        const index = x + y * dims.x + z * (dims.x * dims.y);
                        const dx = (x - cx);
                        const dy = (y - cy);
                        const dz = (z - cz);
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        let value = 0;
                        if (dist < cx * 0.9 && dist > cx * 0.8) value = 800 + Math.random() * 200; // Skull
                        else if (dist <= cx * 0.8) value = 400 + Math.sin(x * 0.1) * 50 + Math.random() * 50; // Brain
                        else value = Math.random() * 10; // Air

                        data[index] = value;
                        if (value < min) min = value;
                        if (value > max) max = value;
                    }
                }
            }
            return { data, dims, min, max };
        }

        /**
         * RENDERING
         */
        /**
         * SEGMENTATION & THRESHOLDING
         */
        class SegmentationProcessor {

            static applyBinary(volume, threshold) {
                // Creates a binary mask where Vol >= Threshold
                const { dims, data } = volume;
                const size = dims.x * dims.y * dims.z;
                const maskData = new Float32Array(size);

                for (let i = 0; i < size; i++) {
                    maskData[i] = (data[i] >= threshold) ? 1 : 0;
                }
                return { dims, data: maskData }; // Mask object
            }

            static applyBinaryInverted(volume, threshold) {
                const { dims, data } = volume;
                const size = dims.x * dims.y * dims.z;
                const maskData = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    maskData[i] = (data[i] < threshold) ? 1 : 0;
                }
                return { dims, data: maskData };
            }

            static applyTruncate(volume, ceil) {
                // Modifies VOLUME, not Mask. Caps values > ceil to ceil.
                // Useful for removing high-intensity artifacts (metal, skull)
                const { dims, data } = volume;
                const newVol = ImageProcessor.cloneVolume(volume);
                const nd = newVol.data;
                for (let i = 0; i < nd.length; i++) {
                    if (nd[i] > ceil) nd[i] = ceil;
                }
                return newVol;
            }

            static applyRangePass(volume, minV, maxV) {
                const { dims, data } = volume;
                const size = dims.x * dims.y * dims.z;
                const maskData = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    maskData[i] = (data[i] >= minV && data[i] <= maxV) ? 1 : 0;
                }
                return { dims, data: maskData };
            }

            // --- Automated ---

            static getHistogram(volume, bins = 1024) {
                const data = volume.data;
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < data.length; i += 10) { // Subsample for speed
                    if (data[i] < min) min = data[i];
                    if (data[i] > max) max = data[i];
                }
                const range = max - min;
                const hist = new Float32Array(bins);

                for (let i = 0; i < data.length; i++) {
                    const idx = Math.floor(((data[i] - min) / (range + 0.0001)) * (bins - 1));
                    hist[idx]++;
                }
                return { hist, min, max, binSize: range / bins };
            }

            static computeOtsu(volume) {
                const { hist, min, binSize } = this.getHistogram(volume, 256);
                const total = volume.data.length;

                let sum = 0;
                for (let t = 0; t < 256; t++) sum += t * hist[t];

                let sumB = 0;
                let wB = 0;
                let wF = 0;

                let maxVar = 0;
                let thresholdIdx = 0;

                for (let t = 0; t < 256; t++) {
                    wB += hist[t];
                    if (wB === 0) continue;

                    wF = total - wB;
                    if (wF === 0) break;

                    sumB += t * hist[t];

                    const mB = sumB / wB;
                    const mF = (sum - sumB) / wF;

                    // Inter-class variance
                    const varBetween = wB * wF * (mB - mF) * (mB - mF);

                    if (varBetween > maxVar) {
                        maxVar = varBetween;
                        thresholdIdx = t;
                    }
                }
                return min + thresholdIdx * binSize;
            }

            static computeLi(volume) {
                // Li's Minimum Cross Entropy (Iterative)
                // 1. Calculate Mean
                const { hist, min, binSize } = this.getHistogram(volume, 256);
                let total = 0, sum = 0;
                for (let i = 0; i < 256; i++) { total += hist[i]; sum += i * hist[i]; }
                if (total === 0) return min;

                let mean = sum / total;
                let t_next = mean;
                let t_prev = min;
                const tolerance = 0.5;

                // Iteratively refine
                for (let iter = 0; iter < 100; iter++) {
                    t_prev = t_next;

                    // Mean of background (<= t) and foreground (> t)
                    let sumB = 0, wB = 0, sumF = 0, wF = 0;
                    // Map threshold to index
                    const tIdx = Math.floor((t_prev));

                    for (let i = 0; i < 256; i++) {
                        if (i <= tIdx) { wB += hist[i]; sumB += i * hist[i]; }
                        else { wF += hist[i]; sumF += i * hist[i]; }
                    }

                    const mB = wB > 0 ? sumB / wB : 0;
                    const mF = wF > 0 ? sumF / wF : 0;

                    // Li's formula for next threshold: (mB - mF) / (log(mB) - log(mF))  ... derivation varies
                    // Simpler version: T = (mean_back + mean_fore)/2? No that's IsoData.
                    // Li optimizes J = -Sum( p * log(p) )
                    // Approximation: new_T = (mF - mB) / (Math.log(mF) - Math.log(mB))
                    if (mF <= 0 || mB <= 0 || mF === mB) break;

                    const nextVal = (mF - mB) / (Math.log(mF) - Math.log(mB));
                    // Check bounds
                    if (!isFinite(nextVal)) break;
                    t_next = nextVal;

                    if (Math.abs(t_next - t_prev) < tolerance) break;
                }

                return min + t_next * binSize;
            }

            static computeMultiOtsu(volume) {
                // Simplified Multi-Otsu for 3 classes (2 thresholds)
                // Exhaustive search is O(L^2), acceptable for L=64 or 128 bins.
                const L = 64;
                const { hist, min, binSize } = this.getHistogram(volume, L);
                const total = volume.data.length;

                // Precompute probabilities and means
                // P(i) and S(i)
                const P = new Float32Array(L + 1);
                const S = new Float32Array(L + 1);
                P[0] = 0; S[0] = 0;
                for (let i = 1; i <= L; i++) {
                    P[i] = P[i - 1] + hist[i - 1];
                    S[i] = S[i - 1] + (i - 1) * hist[i - 1];
                }
                const globalMean = S[L] / total;

                let maxSig = 0;
                let t1_best = 0;
                let t2_best = 0;

                // Iterate t1 from 0 to L-2
                // Iterate t2 from t1+1 to L-1
                for (let t1 = 0; t1 < L - 2; t1++) {
                    const w0 = P[t1 + 1];
                    if (w0 === 0) continue;
                    const u0 = S[t1 + 1] / w0;

                    for (let t2 = t1 + 1; t2 < L - 1; t2++) {
                        const w1 = P[t2 + 1] - P[t1 + 1];
                        if (w1 === 0) continue;
                        const w2 = total - P[t2 + 1];
                        if (w2 === 0) continue;

                        const u1 = (S[t2 + 1] - S[t1 + 1]) / w1;
                        const u2 = (S[L] - S[t2 + 1]) / w2;

                        // Sigma_B^2 = w0*(u0-uT)^2 + w1*(u1-uT)^2 + w2*(u2-uT)^2
                        const sig = w0 * (u0 - globalMean) * (u0 - globalMean) +
                            w1 * (u1 - globalMean) * (u1 - globalMean) +
                            w2 * (u2 - globalMean) * (u2 - globalMean);

                        if (sig > maxSig) {
                            maxSig = sig;
                            t1_best = t1;
                            t2_best = t2;
                        }
                    }
                }

                // Return mask with 0, 1, 2
                const thresh1 = min + t1_best * binSize;
                const thresh2 = min + t2_best * binSize;

                // Generate Label Map
                const { data, dims } = volume;
                const mask = new Float32Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    const v = data[i];
                    if (v < thresh1) mask[i] = 1; // BG 1
                    else if (v < thresh2) mask[i] = 2; // Tissue 1
                    else mask[i] = 3; // Tissue 2
                }
                return { dims, data: mask };
            }

            static applyLocalAdaptive(volume) {
                const { dims, data } = volume;
                const w = dims.x, h = dims.y, d = dims.z;
                const strideXY = w * h;
                const out = new Float32Array(data.length);

                // Use Integral Image (Summed Area Table) for fast box filter in 1 pass?
                // Or simple Gaussian subtraction. 
                // T = GaussianMean(I) - C
                // Mask = I > T

                // Reuse ImageProcessor.applyGaussian
                // BUT applyGaussian modifies in place, so clone first
                const blurred = ImageProcessor.cloneVolume(volume);
                ImageProcessor.applyGaussian(blurred, 2.0); // sigma=2.0 -> block size ~ 13

                const bData = blurred.data;
                for (let i = 0; i < data.length; i++) {
                    // Local threshold = LocalMean - Constant(10?)
                    const thresh = bData[i] - 10;
                    out[i] = (data[i] > thresh) ? 1 : 0;
                }
                return { dims, data: out };
            }
        }

        ImageProcessor.applyBinaryInverted = SegmentationProcessor.applyBinaryInverted; // alias if needed or keep separate

        function applyWindowLevel(val, wWidth, wCenter, map, invert) {
            const lower = wCenter - wWidth / 2;
            const upper = wCenter + wWidth / 2;
            let norm = (val - lower) / (upper - lower);
            norm = Math.max(0, Math.min(1, norm));
            if (invert) norm = 1.0 - norm;

            const intensity = Math.floor(norm * 255);

            if (map === 'hot') return [intensity, 0, 0, 255];
            if (map === 'cool') return [0, intensity, intensity, 255];
            if (map === 'rainbow') {
                const r = Math.floor(Math.sin(norm * Math.PI) * 255);
                const g = Math.floor(Math.sin(norm * Math.PI + 2) * 255);
                const b = Math.floor(Math.sin(norm * Math.PI + 4) * 255);
                return [Math.abs(r), Math.abs(g), Math.abs(b), 255];
            }
            return [intensity, intensity, intensity, 255];
        }

        function getMaskColor(val) {
            if (val <= 0) return null;
            const colors = [
                [255, 0, 0],   // 1 Red
                [0, 255, 0],   // 2 Green
                [0, 0, 255],   // 3 Blue
                [255, 255, 0], // 4 Yellow
                [0, 255, 255], // 5 Cyan
                [255, 0, 255]  // 6 Magenta
            ];
            const idx = (Math.round(val) - 1) % colors.length;
            return colors[idx];
        }

        function getLabelRgb(val) {
            if (val <= 0) return null;
            if (state.labelMap && state.labelMap[val]) {
                const entry = state.labelMap[val];
                if (typeof entry === 'object' && entry !== null && entry.color) {
                    const parsed = parseHexColor(entry.color);
                    if (parsed) return parsed;
                }
            }
            return getMaskColor(val);
        }
        function parseHexColor(str) {
            if (!str) return null;
            str = String(str).trim();
            if (str.startsWith('#')) {
                let s = str.slice(1);
                if (s.length === 3) s = s.split('').map(ch => ch + ch).join('');
                if (s.length !== 6) return null;
                const r = parseInt(s.slice(0, 2), 16);
                const g = parseInt(s.slice(2, 4), 16);
                const b = parseInt(s.slice(4, 6), 16);
                return [r, g, b];
            }
            if (str.startsWith('rgb')) {
                const m = str.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
                if (m) return [parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3], 10)];
            }
            return null;
        }

        function rgbToHex(rgb) {
            if (!rgb || !Array.isArray(rgb)) return '#ff0000';
            const [r, g, b] = rgb;
            return '#' + [r, g, b].map(v => {
                const s = Math.max(0, Math.min(255, Math.round(v))).toString(16);
                return s.length === 1 ? '0' + s : s;
            }).join('');
        }

        function populateLabelColorUI() {
            const container = document.getElementById('label-colors');
            if (!container) return;
            container.innerHTML = '';

            // Determine labels: from mask if available, otherwise from state.labelMap
            const labels = new Set();
            if (state.mask && state.mask.data) {
                const vals = state.mask.data;
                for (let i = 0; i < vals.length; i++) {
                    const v = Math.round(vals[i]);
                    if (v > 0) labels.add(v);
                    if (labels.size >= 200) break;
                }
            }
            // Include any labels from labelMap
            if (state.labelMap) {
                for (const k of Object.keys(state.labelMap)) labels.add(Number(k));
            }

            if (labels.size === 0) {
                container.innerHTML = '<div class="text-neutral-500 text-xs">No labels available. Load a mask or label config.</div>';
                return;
            }

            const labelList = Array.from(labels).sort((a, b) => a - b);
            labelList.forEach(lab => {
                const row = document.createElement('div');
                row.className = 'flex items-center gap-2';

                const lbl = document.createElement('div');
                lbl.className = 'w-8 text-xs font-mono text-neutral-300';
                lbl.textContent = lab;

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'flex-1 bg-neutral-800 border border-neutral-700 rounded p-1 text-white text-xs';
                const mapVal = state.labelMap && state.labelMap[lab];
                let name = '';
                let color = null;
                if (mapVal) {
                    if (typeof mapVal === 'string') name = mapVal;
                    else if (typeof mapVal === 'object') { name = mapVal.name || ''; color = mapVal.color || null; }
                }
                if (!name) name = 'Label_' + lab;
                nameInput.value = name;

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'w-10 h-8 p-0 border-0';
                if (!color) {
                    const def = getMaskColor(lab) || [255, 0, 0];
                    colorInput.value = rgbToHex(def);
                } else {
                    colorInput.value = parseHexColor(color) ? (color.startsWith('#') ? color : rgbToHex(parseHexColor(color))) : '#ff0000';
                }

                // handlers
                colorInput.addEventListener('input', (e) => {
                    const c = e.target.value;
                    state.labelMap = state.labelMap || {};
                    const existing = state.labelMap[lab];
                    if (existing && typeof existing === 'object') existing.color = c, existing.name = existing.name || nameInput.value;
                    else state.labelMap[lab] = { name: nameInput.value, color: c };
                    renderAll();
                    updateVTKVolume();
                    try { render3D(); } catch (e) { }
                });

                nameInput.addEventListener('change', (e) => {
                    const nm = e.target.value || ('Label_' + lab);
                    state.labelMap = state.labelMap || {};
                    const existing = state.labelMap[lab];
                    if (existing && typeof existing === 'object') existing.name = nm;
                    else state.labelMap[lab] = { name: nm, color: colorInput.value };
                    renderAll();
                    updateVTKVolume();
                });

                row.appendChild(lbl);
                row.appendChild(nameInput);
                row.appendChild(colorInput);
                container.appendChild(row);
            });

            // Wire reset/refresh buttons
            const btnReset = document.getElementById('btn-reset-label-colors');
            if (btnReset) btnReset.onclick = () => {
                for (const lab of labelList) {
                    state.labelMap[lab] = { name: state.labelMap && state.labelMap[lab] && state.labelMap[lab].name ? state.labelMap[lab].name : ('Label_' + lab), color: rgbToHex(getMaskColor(lab) || [255, 0, 0]) };
                }
                populateLabelColorUI();
                renderAll(); updateVTKVolume(); try { render3D(); } catch (e) { }
            };
            const btnRefresh = document.getElementById('btn-refresh-label-colors');
            if (btnRefresh) btnRefresh.onclick = () => { populateLabelColorUI(); };
        }

        // Reusable Temp Canvas for Offscreen Rendering
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        function drawViewport(axis) {
            if (!state.volume) return;

            const container = els.viewports[axis];
            const canvas = container.querySelector('canvas');
            const wrapper = canvas.parentElement;
            const vpState = state.ui.viewports[axis];

            let w, h;
            const d = state.volume.dims;
            if (axis === 'axial') { w = d.x; h = d.y; }
            else if (axis === 'sagittal') { w = d.y; h = d.z; }
            else if (axis === 'coronal') { w = d.x; h = d.z; }

            // Resize main canvas to container (Display Resolution) with devicePixelRatio support
            const rect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            canvas.width = Math.max(1, Math.floor(rect.width * dpr));
            canvas.height = Math.max(1, Math.floor(rect.height * dpr));
            const ctx = canvas.getContext('2d');
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // Adaptive sampling: if source image is very large, sample to a reasonable working size
            const maxPixels = 1024 * 1024; // target ~1MP working canvas for speed
            const sample = Math.max(1, Math.ceil(Math.sqrt((w * h) / maxPixels)));
            const srcW = Math.ceil(w / sample);
            const srcH = Math.ceil(h / sample);

            // Resize temp canvas to sampled image size
            if (tempCanvas.width !== srcW || tempCanvas.height !== srcH) {
                tempCanvas.width = srcW;
                tempCanvas.height = srcH;
            }

            // 1. GENERATE PIXELS (Sampled Source Resolution)
            const imgData = tempCtx.createImageData(srcW, srcH);
            const pixels = imgData.data;
            const vol1 = state.volume;
            if (!vol1) return;
            const data1 = vol1.data;
            const vol2 = state.secondaryVolume;
            const data2 = vol2 ? vol2.data : null;
            const strideXY = d.x * d.y;

            const sliceIdx = axis === 'axial' ? state.crosshair.z :
                axis === 'sagittal' ? state.crosshair.x :
                    state.crosshair.y;

            const showMask = state.mask && state.settings.showMask;
            const maskOp = state.settings.maskOpacity;
            const dualEnabled = state.settings.dualViewEnabled && data2;
            const dualAlpha = dualEnabled ? (state.settings.dualViewOpacity || 0.5) : 0;

            for (let row = 0; row < srcH; row++) {
                for (let col = 0; col < srcW; col++) {
                    const srcX = Math.min(w - 1, col * sample);
                    const srcY = Math.min(h - 1, row * sample);
                    let x, y, z;

                    if (axis === 'axial') {
                        x = srcX;
                        y = (d.y - 1) - srcY; // Flip Y: Anterior (top) vs Posterior (bottom)
                        z = sliceIdx;
                    }
                    else if (axis === 'sagittal') {
                        x = sliceIdx;
                        y = srcX;
                        z = (d.z - 1) - srcY; // Flip Z: Superior (head) at top
                    }
                    else if (axis === 'coronal') {
                        x = srcX;
                        y = sliceIdx;
                        z = (d.z - 1) - srcY; // Flip Z: Superior (head) at top
                    }

                    if (x < 0 || x >= d.x || y < 0 || y >= d.y || z < 0 || z >= d.z) continue;

                    const idx = x + y * d.x + z * strideXY;
                    const mode = state.settings.dualMode || 'blend';
                    const dualEnabled = state.settings.dualViewEnabled && data2;

                    let r, g, b, a;

                    // OPTIMIZED SOURCE SELECTION
                    if (dualEnabled && mode === 'split') {
                        // If we are on the right half of the sampled width, use Volume 2
                        if (col >= Math.floor(srcW * 0.5)) {
                            const val2 = data2[idx];
                            [r, g, b, a] = applyWindowLevel(val2, state.settings.windowWidth, state.settings.windowCenter, state.settings.colorMap, state.settings.invert);
                        } else {
                            const val1 = data1[idx];
                            [r, g, b, a] = applyWindowLevel(val1, state.settings.windowWidth, state.settings.windowCenter, state.settings.colorMap, state.settings.invert);
                        }
                    } else {
                        // Standard path for Blend, Difference, or Single View
                        const val1 = data1[idx];
                        [r, g, b, a] = applyWindowLevel(val1, state.settings.windowWidth, state.settings.windowCenter, state.settings.colorMap, state.settings.invert);

                        if (dualEnabled) {
                            const val2 = data2[idx];
                            if (mode === 'blend') {
                                const [r2, g2, b2] = applyWindowLevel(val2, state.settings.windowWidth, state.settings.windowCenter, 'hot', false);
                                const alpha = state.settings.dualViewOpacity || 0.5;
                                r = r * (1 - alpha) + r2 * alpha;
                                g = g * (1 - alpha) + g2 * alpha;
                                b = b * (1 - alpha) + b2 * alpha;
                            } else if (mode === 'difference') {
                                const window = state.settings.windowWidth || 1;
                                let diff = (val1 - val2) / window;
                                diff = Math.max(-1, Math.min(1, diff));
                                const alpha = Math.abs(diff);
                                const diffColor = diff > 0 ? [255, 0, 0] : [0, 0, 255];
                                r = r * (1 - alpha) + diffColor[0] * alpha;
                                g = g * (1 - alpha) + diffColor[1] * alpha;
                                b = b * (1 - alpha) + diffColor[2] * alpha;
                            }
                        }
                    }

                    // Mask Overlay (Remains same)
                    if (showMask) {
                        const mVal = state.mask.data[idx];
                        const mColor = getLabelRgb(mVal);
                        if (mColor) {
                            r = r * (1 - maskOp) + mColor[0] * maskOp;
                            g = g * (1 - maskOp) + mColor[1] * maskOp;
                            b = b * (1 - maskOp) + mColor[2] * maskOp;
                        }
                    }

                    const pxIndex = (row * srcW + col) * 4;
                    pixels[pxIndex] = r;
                    pixels[pxIndex + 1] = g;
                    pixels[pxIndex + 2] = b;
                    pixels[pxIndex + 3] = 255;
                }
            }
            tempCtx.putImageData(imgData, 0, 0);

            // 2. DRAW TO DISPLAY (Fit Contain + Pan/Zoom)
            ctx.imageSmoothingEnabled = true; // smoother scaled image
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate "Contain" Ratio using CSS pixels (we transformed context to dpr)
            const scaleX = rect.width / w;
            const scaleY = rect.height / h;
            const baseScale = Math.min(scaleX, scaleY); // Fit whole image

            // Center offsets (in CSS pixels)
            const offsetX = (rect.width - w * baseScale) / 2;
            const offsetY = (rect.height - h * baseScale) / 2;

            ctx.save();

            // Apply transforms: Translate Center -> Apply Pan -> Apply Zoom -> Apply Base Scale
            // Note: Pan is stored in CSS pixels, so scale it by baseScale to apply before zoom scaling
            ctx.translate(offsetX + vpState.pan.x * baseScale, offsetY + vpState.pan.y * baseScale);
            ctx.scale(baseScale * vpState.zoom, baseScale * vpState.zoom);

            // Draw sampled tempCanvas scaled back to full image size in image-space coordinates
            ctx.drawImage(tempCanvas, 0, 0, srcW, srcH, 0, 0, w, h);

            // 3. DRAW CROSSHAIRS (Transformed space)
            if (state.settings.showCrosshair) {
                let cx = 0, cy = 0;
                if (axis === 'axial') { cx = state.crosshair.x; cy = state.crosshair.y; }
                else if (axis === 'sagittal') { cx = state.crosshair.y; cy = state.crosshair.z; }
                else if (axis === 'coronal') { cx = state.crosshair.x; cy = state.crosshair.z; }

                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 1 / (baseScale * vpState.zoom); // Keep line thin
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                // Crosshair spans the whole image, not just canvas
                ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
                ctx.moveTo(0, cy); ctx.lineTo(w, cy);
                ctx.stroke();
            }

            ctx.restore();

            //container.querySelector('.overlay-text').textContent = `${axis.toUpperCase()} [${sliceIdx}]`;
            const label = container.querySelector('.vp-label');
            if (label) {
                label.textContent = `${axis.toUpperCase()} [${sliceIdx}]`;
            }
        }

        // Enhanced 3D render: optimized with caching and proper LOD
        let _3d_animHandle = null;
        state.ui._3dRotateVel = { x: 0, y: 0 };
        state.ui.vtkLoading = false;

        // 3D caching system
        const _3dCache = {
            canvas: null,
            ctx: null,
            points: null,
            lastMaskId: null,
            lastQuality: 70,
            lastDims: null,
            needsRegen: true
        };

        function _3dInitCache() {
            if (!_3dCache.canvas) {
                _3dCache.canvas = document.createElement('canvas');
                _3dCache.ctx = _3dCache.canvas.getContext('2d');
            }
        }

        function _3dRegeneratePoints() {
            if (!state.mask || !state.volume) {
                _3dCache.points = null;
                _3dCache.glPoints = null;
                return;
            }

            const d = state.volume.dims;
            const q = state.settings.renderQuality || 70;

            const maskId = state.mask._cacheId || (state.mask._cacheId = Math.random());
            const dimsKey = `${d.x}-${d.y}-${d.z}`;

            if (_3dCache.lastMaskId === maskId &&
                _3dCache.lastQuality === q &&
                _3dCache.lastDims === dimsKey &&
                _3dCache.points) {
                return;
            }

            _3dCache.lastMaskId = maskId;
            _3dCache.lastQuality = q;
            _3dCache.lastDims = dimsKey;

            const totalVoxels = d.x * d.y * d.z;
            const targetPoints = Math.max(1000, Math.min(10000, Math.round(500 + (q / 100) * 8000)));
            const approxStride = Math.pow(totalVoxels / targetPoints, 1 / 3);
            const stride = Math.max(1, Math.floor(approxStride));

            const points = [];
            const strideXY = d.x * d.y;
            const maskData = state.mask.data;

            const cx = d.x / 2, cy = d.y / 2, cz = d.z / 2;

            for (let z = 0; z < d.z; z += stride) {
                const zOffset = z * strideXY;
                for (let y = 0; y < d.y; y += stride) {
                    const yzOffset = y * d.x + zOffset;
                    for (let x = 0; x < d.x; x += stride) {
                        const idx = x + yzOffset;
                        const mv = maskData[idx];
                        if (mv > 0) {
                            const col = getLabelRgb(mv) || [255, 100, 100];
                            points.push({
                                x: (x - cx) / d.x,
                                y: (y - cy) / d.y,
                                z: (z - cz) / d.z,
                                color: col
                            });
                        }
                    }
                }
            }

            points.sort((a, b) => a.z - b.z);
            _3dCache.points = points;
            _3dCache.glPoints = null;
            _3dCache.needsRegen = false;
        }

        const _3dGL = {
            canvas: null,
            gl: null,
            program: null,
            buffers: null
        };

        function _3dInitWebGL() {
            if (_3dGL.gl) return true;

            const canvas = document.createElement('canvas');
            canvas.style.display = 'none';
            document.body.appendChild(canvas);
            _3dGL.canvas = canvas;

            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            if (!gl) return false;

            _3dGL.gl = gl;

            const vsSource = `
                attribute vec3 aPosition;
                attribute vec3 aColor;
                varying vec3 vColor;
                varying float vDepth;
                uniform float uAngleX;
                uniform float uAngleY;
                uniform float uScale;
                uniform vec2 uResolution;

                void main() {
                    float cx = cos(uAngleX), sx = sin(uAngleX);
                    float cy = cos(uAngleY), sy = sin(uAngleY);

                    float x1 = aPosition.x * cy - aPosition.z * sy;
                    float z1 = aPosition.x * sy + aPosition.z * cy;
                    float y2 = aPosition.y * cx - z1 * sx;

                    gl_Position = vec4(x1 * uScale, y2 * uScale, z1 * 0.5 + 0.5, 1.0);
                    gl_PointSize = max(1.0, 4.0 - z1 * 2.0);
                    vColor = aColor;
                    vDepth = z1;
                }
            `;

            const fsSource = `
                precision mediump float;
                varying vec3 vColor;
                varying float vDepth;

                void main() {
                    float alpha = 0.9 - vDepth * 0.6;
                    gl_FragColor = vec4(vColor, alpha);
                }
            `;

            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource);
            gl.compileShader(vs);

            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSource);
            gl.compileShader(fs);

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('WebGL program link error:', gl.getProgramInfoLog(program));
                return false;
            }

            _3dGL.program = program;
            return true;
        }

        function _3dRenderWebGL() {
            if (!_3dGL.gl && !_3dInitWebGL()) {
                return false;
            }

            if (!_3dCache.points || _3dCache.points.length === 0) {
                return false;
            }

            const gl = _3dGL.gl;
            const canvas = _3dGL.canvas;
            const rect = els.viewports.v3d.parentElement.getBoundingClientRect();

            canvas.width = rect.width;
            canvas.height = rect.height;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.clearColor(0.04, 0.04, 0.06, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

            const program = _3dGL.program;
            gl.useProgram(program);

            if (!_3dCache.glPoints) {
                const points = _3dCache.points;
                const positions = new Float32Array(points.length * 3);
                const colors = new Float32Array(points.length * 3);

                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    positions[i * 3] = p.x;
                    positions[i * 3 + 1] = p.y;
                    positions[i * 3 + 2] = p.z;
                    colors[i * 3] = p.color[0] / 255;
                    colors[i * 3 + 1] = p.color[1] / 255;
                    colors[i * 3 + 2] = p.color[2] / 255;
                }

                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

                _3dCache.glBuffers = { pos: posBuffer, color: colorBuffer };
                _3dCache.glPointCount = points.length;
            }

            const angleX = state.ui.rotate3D.x + Math.PI / 6;
            const angleY = state.ui.rotate3D.y + Math.PI / 6;
            const scale = 0.35;

            gl.uniform1f(gl.getUniformLocation(program, 'uAngleX'), angleX);
            gl.uniform1f(gl.getUniformLocation(program, 'uAngleY'), angleY);
            gl.uniform1f(gl.getUniformLocation(program, 'uScale'), scale);
            gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), canvas.width, canvas.height);

            const posLoc = gl.getAttribLocation(program, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, _3dCache.glBuffers.pos);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            const colorLoc = gl.getAttribLocation(program, 'aColor');
            gl.bindBuffer(gl.ARRAY_BUFFER, _3dCache.glBuffers.color);
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, _3dCache.glPointCount);

            return true;
        }

        function render3D() {
            if (!state.mask || !state.settings.showMask) {
                els.labels.text3d.classList.remove('hidden');
                disposeVTK3D();
                _3dCache.glPoints = null;
                document.getElementById('3d-rendering')?.classList.add('hidden');
                return;
            }

            els.labels.text3d.classList.add('hidden');
            document.getElementById('3d-rendering')?.classList.remove('hidden');

            const useVTK = typeof vtk !== 'undefined';

            if (useVTK) {
                try {
                    const container = els.viewports.v3d.parentElement;
                    if (!state.ui.vtk || !state.ui.vtk.initialized) {
                        initVTK3D(container);
                    }
                    _3dCache.glPoints = null;
                    updateVTKVolume();
                    document.getElementById('3d-rendering')?.classList.add('hidden');
                    return;
                } catch (err) {
                    console.warn('VTK render failed, falling back to canvas:', err);
                }
            }

            if (!useVTK && !state.ui.vtkLoading) {
                state.ui.vtkLoading = true;
                LibraryLoader.loadVTK().then(() => {
                    state.ui.vtkLoading = false;
                    document.getElementById('3d-rendering')?.classList.add('hidden');
                    if (state.mask && state.settings.showMask) {
                        try {
                            const container = els.viewports.v3d.parentElement;
                            initVTK3D(container);
                            _3dCache.glPoints = null;
                            updateVTKVolume();
                            return;
                        } catch (err) {
                            console.warn('VTK init failed, using canvas fallback:', err);
                        }
                    }
                    renderOptimizedFallback3D();
                }).catch(() => {
                    state.ui.vtkLoading = false;
                    renderOptimizedFallback3D();
                });
                return;
            }

            document.getElementById('3d-rendering')?.classList.add('hidden');
            renderOptimizedFallback3D();
        }

        function renderOptimizedFallback3D() {
            if (!state.mask || !state.settings.showMask) {
                document.getElementById('3d-rendering')?.classList.add('hidden');
                return;
            }

            const canvas = els.viewports.v3d;
            const rect = canvas.parentElement.getBoundingClientRect();

            _3dInitCache();
            _3dRegeneratePoints();

            if (!_3dCache.points || _3dCache.points.length === 0) {
                document.getElementById('3d-rendering')?.classList.add('hidden');
                return;
            }

            if (_3dRenderWebGL()) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(_3dGL.canvas, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
                document.getElementById('3d-rendering')?.classList.add('hidden');
                return;
            }

            const ctx = canvas.getContext('2d', { alpha: false });
            const dpr = Math.min(window.devicePixelRatio || 1, 1.5);

            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            canvas.width = Math.max(1, Math.floor(rect.width * dpr));
            canvas.height = Math.max(1, Math.floor(rect.height * dpr));
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, rect.width, rect.height);

            const d = state.volume.dims;
            const cx = rect.width / 2;
            const cy = rect.height / 2;
            const scale = Math.min(rect.width, rect.height) * 0.4;

            const angleX = state.ui.rotate3D.x + Math.PI / 6;
            const angleY = state.ui.rotate3D.y + Math.PI / 6;
            const cosX = Math.cos(angleX), sinX = Math.sin(angleX);
            const cosY = Math.cos(angleY), sinY = Math.sin(angleY);

            const points = _3dCache.points;
            const len = points.length;

            const size = Math.max(1, Math.min(4, (state.settings.renderQuality || 70) / 25));

            ctx.globalCompositeOperation = 'lighter';

            for (let i = 0; i < len; i++) {
                const p = points[i];

                const x1 = p.x * cosY - p.z * sinY;
                const z1 = p.x * sinY + p.z * cosY;
                const y2 = p.y * cosX - z1 * sinX;

                const screenX = cx + x1 * scale;
                const screenY = cy + y2 * scale;
                const depth = 0.5 + z1 * 0.5;

                const alpha = Math.max(0.1, Math.min(0.9, 0.6 - depth * 0.4));

                ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${alpha.toFixed(3)})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.globalCompositeOperation = 'source-over';
            document.getElementById('3d-rendering')?.classList.add('hidden');
        }

        let _3dNeedsRender = true;
        let _3dIsRendering = false;
        function _3dStartLoop() {
            if (_3d_animHandle) return;
            const loop = () => {
                const hasVelocity = Math.abs(state.ui._3dRotateVel.x) > 0.0001 || Math.abs(state.ui._3dRotateVel.y) > 0.0001;

                if (hasVelocity) {
                    state.ui.rotate3D.x += state.ui._3dRotateVel.x;
                    state.ui.rotate3D.y += state.ui._3dRotateVel.y;
                    state.ui._3dRotateVel.x *= 0.92;
                    state.ui._3dRotateVel.y *= 0.92;
                    _3dNeedsRender = true;
                }

                if (_3dNeedsRender && !_3dIsRendering) {
                    _3dIsRendering = true;
                    requestAnimationFrame(() => {
                        const useVTK = typeof vtk !== 'undefined' && state.ui.vtk && state.ui.vtk.initialized;
                        if (useVTK) {
                            if (state.ui.vtk.renderWindow) state.ui.vtk.renderWindow.render();
                        } else {
                            renderOptimizedFallback3D();
                        }
                        _3dNeedsRender = false;
                        _3dIsRendering = false;
                    });
                }

                if (hasVelocity || _3dNeedsRender) {
                    _3d_animHandle = requestAnimationFrame(loop);
                } else {
                    _3d_animHandle = null;
                }
            };
            _3d_animHandle = requestAnimationFrame(loop);
        }

        function _3dStopLoop() {
            if (_3d_animHandle) cancelAnimationFrame(_3d_animHandle);
            _3d_animHandle = null;
        }

        function _3dRequestRender() {
            _3dNeedsRender = true;
        }

        // --- vtk.js Volume Rendering Integration ---
        function initVTK3D(container) {
            if (typeof vtk === 'undefined') return;
            if (!container) container = document.body;

            const fullScreenRenderer = vtk.Rendering.Misc.vtkFullScreenRenderWindow.newInstance({ rootContainer: container, containerStyle: { height: '100%', width: '100%' } });
            const renderer = fullScreenRenderer.getRenderer();
            const renderWindow = fullScreenRenderer.getRenderWindow();

            // Create volume pipeline
            const volume = vtk.Rendering.Core.vtkVolume.newInstance();
            const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();
            // Use a slightly smaller sample distance for smoother result (costlier but nicer)
            mapper.setSampleDistance(0.6);
            volume.setMapper(mapper);

            // Transfer functions
            const ctfun = vtk.Rendering.Core.vtkColorTransferFunction.newInstance();
            const ofun = vtk.Common.DataModel.vtkPiecewiseFunction.newInstance();

            volume.getProperty().setRGBTransferFunction(0, ctfun);
            volume.getProperty().setScalarOpacity(0, ofun);
            volume.getProperty().setScalarOpacityUnitDistance(0, 2.0);
            volume.getProperty().setInterpolationTypeToLinear();
            // Enable shading to improve visual smoothness and depth
            try {
                volume.getProperty().setShade(true);
                volume.getProperty().setAmbient(0.15);
                volume.getProperty().setDiffuse(0.85);
                volume.getProperty().setSpecular(0.25);
                volume.getProperty().setSpecularPower(12.0);
            } catch (e) { }

            renderer.addVolume(volume);
            renderer.setBackground(0.02, 0.03, 0.04);

            state.ui.vtk = { fullScreenRenderer, renderer, renderWindow, mapper, volume, ctfun, ofun, initialized: true };
            // mark that camera should be reset after first volume upload
            state.ui.vtk._needsCameraReset = true;
            // Ensure the VTK canvas sits in our viewport container
            // vtkFullScreenRenderWindow creates its own root; move its container into ours
            // Move vtk's generated container inside our viewport container (ensure proper stacking and pointer handling)
            try {
                const fsContainer = fullScreenRenderer.getContainer ? fullScreenRenderer.getContainer() : null;
                if (fsContainer) {
                    if (fsContainer.parentNode !== container) {
                        // remove from previous parent if needed
                        try { fsContainer.parentNode && fsContainer.parentNode.removeChild(fsContainer); } catch (e) { }
                        container.appendChild(fsContainer);
                    }
                    fsContainer.style.position = 'absolute';
                    fsContainer.style.inset = '0';
                    fsContainer.style.width = '100%';
                    fsContainer.style.height = '100%';
                    fsContainer.style.pointerEvents = 'auto';
                    fsContainer.style.zIndex = '0';
                }
            } catch (e) {
                console.warn('Could not reparent vtk container', e);
            }

            // Hide the 3D placeholder text when vtk is initialized
            try { els.labels.text3d.classList.add('hidden'); } catch (e) { }

            // Ensure container allows pointer events and position context
            try { if (!container.style.position) container.style.position = 'relative'; } catch (e) { }

            // Setup interactor style so user can rotate/zoom/pan and bind it to the vtk container explicitly
            try {
                const interactor = fullScreenRenderer.getInteractor && fullScreenRenderer.getInteractor();
                const fsContainer = fullScreenRenderer.getContainer && fullScreenRenderer.getContainer();
                if (interactor) {
                    if (vtk.Interaction && vtk.Interaction.Style && vtk.Interaction.Style.vtkInteractorStyleTrackballCamera) {
                        const style = vtk.Interaction.Style.vtkInteractorStyleTrackballCamera.newInstance();
                        interactor.setInteractorStyle && interactor.setInteractorStyle(style);
                    }
                    interactor.initialize && interactor.initialize();
                    try {
                        // bind events to the container we appended to the viewport
                        if (interactor.bindEvents && fsContainer) interactor.bindEvents(fsContainer);
                    } catch (e) {
                        console.warn('Failed to bind vtk interactor events', e);
                    }
                }
            } catch (e) {
                console.warn('Failed to configure vtk interactor', e);
            }

            // Responsive
            window.addEventListener('resize', () => {
                if (state.ui.vtk && state.ui.vtk.renderWindow) state.ui.vtk.renderWindow.render();
            });
        }

        function updateVTKVolume() {
            if (!state.ui.vtk || !state.ui.vtk.initialized) return;
            const { mapper, renderer, renderWindow, volume, ctfun, ofun } = state.ui.vtk;
            if (!state.mask) {
                renderer.render();
                return;
            }

            const d = state.mask.dims;

            const imageData = vtk.Common.DataModel.vtkImageData.newInstance();
            imageData.setOrigin(0, 0, 0);
            const sp = state.mask.voxelDims || (state.volume && state.volume.voxelDims) || { x: 1, y: 1, z: 1 };
            imageData.setSpacing(sp.x || 1.0, sp.y || 1.0, sp.z || 1.0);
            imageData.setDimensions(d.x, d.y, d.z);

            let values = state.mask.data;
            if (!(values instanceof Float32Array)) values = new Float32Array(values);

            const dataArray = vtk.Common.Core.vtkDataArray.newInstance({ numberOfComponents: 1, values, dataType: 'Float32' });
            imageData.getPointData().setScalars(dataArray);

            mapper.setInputData(imageData);

            ctfun.removeAllPoints();
            ofun.removeAllPoints();

            ctfun.addRGBPoint(0, 0.0, 0.0, 0.0);
            ofun.addPoint(0, 0.0);

            const vals = values;
            const labels = new Set();
            const limit = 200;
            for (let i = 0; i < vals.length; i++) {
                const v = Math.round(vals[i]);
                if (v > 0) labels.add(v);
                if (labels.size >= limit) break;
            }

            const labelList = Object.keys(state.labelMap || {}).length > 0 ? Object.keys(state.labelMap).map(k => parseInt(k, 10)) : Array.from(labels);
            if (labelList.length === 0) {
                labelList.push(1);
            }

            for (let i = 0; i < labelList.length; i++) {
                const lab = labelList[i];
                let color = null;
                if (state.labelMap && state.labelMap[lab]) {
                    const entry = state.labelMap[lab];
                    if (typeof entry === 'string') {
                    } else if (typeof entry === 'object' && entry !== null) {
                        if (entry.color) color = parseHexColor(entry.color) || null;
                    }
                }
                if (!color) color = getMaskColor(lab) || [255, 0, 0];

                const r = (color[0] || 255) / 255.0;
                const gcol = (color[1] || 0) / 255.0;
                const b = (color[2] || 0) / 255.0;
                ctfun.addRGBPoint(lab, r, gcol, b);
                ofun.addPoint(lab, state.settings.maskOpacity || 0.5);
            }

            try { els.labels.text3d.classList.add('hidden'); } catch (e) { }

            const q = (state.settings && state.settings.renderQuality) ? state.settings.renderQuality : 70;
            const sd_min = 0.25;
            const sd_max = 1.2;
            const sd = sd_max - (q / 100) * (sd_max - sd_min);
            try { mapper.setSampleDistance(sd); } catch (e) { }
            if (state.ui.vtk._needsCameraReset) {
                renderer.resetCamera();
                state.ui.vtk._needsCameraReset = false;
            }
            renderWindow.render();
            document.getElementById('3d-rendering')?.classList.add('hidden');
        }

        function disposeVTK3D() {
            if (!state.ui.vtk) return;
            try {
                state.ui.vtk.renderWindow.getInteractor().unbindEvents();
            } catch (e) { }
            try { state.ui.vtk.fullScreenRenderer.delete(); } catch (e) { }
            state.ui.vtk = null;
            _3dCache.glPoints = null;
        }

        function renderAll(immediate3D = false) {
            const doRender = () => {
                renderAll._scheduled = false;
                renderAll._lastFrame = performance.now();
                drawViewport('axial');
                drawViewport('sagittal');
                drawViewport('coronal');
                if (state.mask) {
                    if (immediate3D) {
                        render3D();
                    } else {
                        requestAnimationFrame(render3D);
                    }
                }
                updateInfo();
            };

            if (renderAll._scheduled) {
                renderAll._pending3D = renderAll._pending3D || immediate3D;
                return;
            }

            renderAll._scheduled = true;
            renderAll._pending3D = immediate3D;

            const now = performance.now();
            const lastFrame = renderAll._lastFrame || 0;
            const minFrameInterval = 1000 / 60;

            if (now - lastFrame >= minFrameInterval) {
                requestAnimationFrame(doRender);
            } else {
                setTimeout(() => requestAnimationFrame(doRender), minFrameInterval - (now - lastFrame));
            }
        }

        function updateInfo() {
            if (!state.volume) return;
            const d = state.volume.dims;
            const x = state.crosshair.x;
            const y = state.crosshair.y;
            const z = state.crosshair.z;

            els.labels.pos.textContent = `[${x}, ${y}, ${z}]`;
            els.labels.dims.textContent = `${d.x} x ${d.y} x ${d.z}`;

            // Get intensity
            const idx = x + y * d.x + z * d.x * d.y;
            const val = state.volume.data[idx];
            els.labels.val.textContent = val ? val.toFixed(1) : '0';
        }

        function setActiveViewport(axis) {
            state.activeAxis = axis;
            Object.values(els.viewports).forEach(el => el && el.classList.remove('active'));
            if (els.viewports[axis]) els.viewports[axis].classList.add('active');
        }

        /**
         * EVENTS
         */

        // File Buttons
        els.inputs.btnLoadMri.addEventListener('click', () => els.inputs.fileMri.click());
        els.inputs.btnLoadMask.addEventListener('click', () => els.inputs.fileMask.click());
        if (els.inputs.btnLoadMri2) els.inputs.btnLoadMri2.addEventListener('click', () => els.inputs.fileMri2.click());

        els.inputs.fileMri.addEventListener('change', (e) => {
            if (e.target.files[0]) handleMriLoad(e.target.files[0]);
        });

        if (els.inputs.fileMri2) els.inputs.fileMri2.addEventListener('change', (e) => {
            if (e.target.files[0]) handleMri2Load(e.target.files[0]);
        });

        els.inputs.fileMask.addEventListener('change', (e) => {
            if (e.target.files[0]) handleMaskLoad(e.target.files[0]);
        });

        // Label Config wiring
        els.inputs.btnLoadLabelConfig.addEventListener('click', () => els.inputs.fileLabelConfig.click());
        els.inputs.fileLabelConfig.addEventListener('change', (e) => {
            if (e.target.files[0]) handleLabelConfigLoad(e.target.files[0]);
        });
        els.inputs.btnSaveLabelConfig.addEventListener('click', (e) => handleLabelConfigSave(e));

        // Volumetric analysis
        document.getElementById('btn-calc-volumes').addEventListener('click', () => calculateVolumes());

        // Generate
        els.inputs.btnGenerate.addEventListener('click', () => {
            els.labels.loading.classList.remove('hidden');
            els.labels.loading.textContent = "Generating Phantom...";
            setTimeout(() => {
                const dims = { x: 180, y: 220, z: 180 };
                const result = generateSyntheticVolume(dims);
                state.volume = result;
                state.mask = null; // clear mask
                state.crosshair = { x: 90, y: 110, z: 90 };
                resetViews();
                state.settings.windowWidth = 400;
                state.settings.windowCenter = 400;

                // Update UI
                els.inputs.ww.value = 400;
                els.inputs.wc.value = 400;
                els.labels.ww.textContent = 400;
                els.labels.wc.textContent = 400;
                els.labels.maskGroup.classList.add('opacity-50', 'pointer-events-none');

                renderAll();
                els.labels.text3d.classList.add('hidden');
                render3D();
                els.labels.loading.classList.add('hidden');
            }, 50);
        });

        // Sliders
        els.inputs.ww.addEventListener('input', (e) => {
            state.settings.windowWidth = Number(e.target.value);
            els.labels.ww.textContent = e.target.value;
            renderAll();
        });
        els.inputs.wc.addEventListener('input', (e) => {
            state.settings.windowCenter = Number(e.target.value);
            els.labels.wc.textContent = e.target.value;
            renderAll();
        });
        els.inputs.maskOpacity.addEventListener('input', (e) => {
            state.settings.maskOpacity = Number(e.target.value);
            els.labels.maskOpacity.textContent = e.target.value;
            renderAll();
        });

        // --- Tool Logic ---
        document.querySelectorAll('input[name="tool"]').forEach(el => {
            el.addEventListener('change', (e) => {
                state.ui.tool = e.target.value;
            });
        });
        document.getElementById('input-brush-size').addEventListener('input', (e) => {
            state.ui.brushSize = Number(e.target.value);
            document.getElementById('val-brush-size').textContent = e.target.value;
        });

        // --- Segmentation UI Wiring ---
        els.inputs.segOp.addEventListener('change', (e) => {
            const val = e.target.value;
            const params = els.inputs.segParams;
            const p1 = els.inputs.segP1;
            const p2 = els.inputs.segP2;

            // Default hidden
            params.classList.add('hidden');

            if (val === 'binary' || val === 'binary_inv') {
                params.classList.remove('hidden');
                params.classList.remove('grid-cols-2');
                p1.placeholder = "Threshold (e.g. 500)";
                p1.value = state.settings.windowCenter ? Math.round(state.settings.windowCenter) : 200;
                p2.classList.add('hidden');
            } else if (val === 'truncate') {
                params.classList.remove('hidden');
                params.classList.remove('grid-cols-2');
                p1.placeholder = "Ceiling Value";
                p2.classList.add('hidden');
            } else if (val === 'range_pass') {
                params.classList.remove('hidden');
                params.classList.add('grid-cols-2');
                p1.placeholder = "Min";
                p2.classList.remove('hidden');
                p2.placeholder = "Max";
            }
        });

        els.inputs.btnRunSeg.addEventListener('click', () => {
            const op = els.inputs.segOp.value;
            if (!op || !state.volume) return alert('Load Volume and select Op');

            els.labels.loading.textContent = "Segmenting...";
            els.labels.loading.classList.remove('hidden');

            setTimeout(() => {
                try {
                    let resMask = null;
                    let resVol = null; // if modifying volume

                    const p1 = Number(els.inputs.segP1.value);
                    const p2 = Number(els.inputs.segP2.value);

                    switch (op) {
                        case 'binary': resMask = SegmentationProcessor.applyBinary(state.volume, p1); break;
                        case 'binary_inv': resMask = SegmentationProcessor.applyBinaryInverted(state.volume, p1); break;
                        case 'truncate': resVol = SegmentationProcessor.applyTruncate(state.volume, p1); break;
                        case 'range_pass': resMask = SegmentationProcessor.applyRangePass(state.volume, p1, p2); break;
                        case 'otsu': {
                            const th = SegmentationProcessor.computeOtsu(state.volume);
                            console.log("Otsu Threshold:", th);
                            resMask = SegmentationProcessor.applyBinary(state.volume, th);
                            alert(`Otsu Threshold: ${th.toFixed(1)}`);
                            break;
                        }
                        case 'li': {
                            const th = SegmentationProcessor.computeLi(state.volume);
                            resMask = SegmentationProcessor.applyBinary(state.volume, th);
                            alert(`Li Threshold: ${th.toFixed(1)}`);
                            break;
                        }
                        case 'multi_otsu': resMask = SegmentationProcessor.computeMultiOtsu(state.volume); break;
                        case 'local_adaptive': resMask = SegmentationProcessor.applyLocalAdaptive(state.volume); break;
                    }

                    if (resVol) {
                        state.volume = resVol;
                        renderAll();
                        // Update 3D
                        try { render3D(); } catch (e) { }
                    }
                    if (resMask) {
                        state.mask = resMask;
                        // Enable mask UI
                        els.inputs.maskCheck.checked = true;
                        state.settings.showMask = true;
                        document.getElementById('group-mask').classList.remove('opacity-50', 'pointer-events-none');

                        populateLabelColorUI();
                        renderAll();
                        updateVTKVolume();
                        try { render3D(); } catch (e) { }
                    }

                } catch (err) {
                    alert(err.message);
                } finally {
                    els.labels.loading.classList.add('hidden');
                }
            }, 50);
        });

        // Image Processing Operations
        if (els.inputs.btnRunOp) {
            els.inputs.btnRunOp.addEventListener('click', () => {
                const op = els.inputs.opSelect.value;
                if (!op) {
                    alert('Please select an operation first.');
                    return;
                }
                if (!state.volume) {
                    alert('Please load an MRI volume first.');
                    return;
                }

                console.log(`Requested operation: ${op}`);
                if (els.inputs.opStatus) {
                    els.inputs.opStatus.textContent = `Running ${op}...`;
                    els.inputs.opStatus.classList.remove('hidden');

                    // Allow UI to update before freezing
                    setTimeout(() => {
                        const start = performance.now();
                        try {
                            const newVol = ImageProcessor.cloneVolume(state.volume);

                            switch (op) {
                                case 'clahe': ImageProcessor.applyCLAHE(newVol, 3.0); break;
                                case 'hist_eq': ImageProcessor.applyHistEq(newVol); break;
                                case 'gamma_bright': ImageProcessor.applyGamma(newVol, 0.6); break;
                                case 'gamma_dark': ImageProcessor.applyGamma(newVol, 1.5); break;
                                case 'sigmoid': ImageProcessor.applySigmoid(newVol, 12, 0.4); break;
                                case 'rescale': ImageProcessor.applyRescale(newVol); break;

                                case 'unsharp': ImageProcessor.applyUnsharp(newVol, 2.0); break;
                                case 'tv_denoise': ImageProcessor.applyTVDenoise(newVol, 4); break;
                                case 'gaussian': ImageProcessor.applyGaussian(newVol, 1.0); break;
                                case 'median_3d': ImageProcessor.applyMedian3D(newVol); break;
                                case 'morph_erosion': ImageProcessor.applyMorphErosion(newVol); break;

                                case 'n4_bias': ImageProcessor.applyN4Bias(newVol); break;
                            }

                            // Update State
                            state.volume = newVol;
                            // Recalc min/max
                            let min = Infinity, max = -Infinity;
                            for (let i = 0; i < newVol.data.length; i++) {
                                if (newVol.data[i] < min) min = newVol.data[i];
                                if (newVol.data[i] > max) max = newVol.data[i];
                            }
                            newVol.min = min; newVol.max = max;

                            // Adjust windows
                            state.settings.windowWidth = max - min;
                            state.settings.windowCenter = (max + min) / 2;
                            els.inputs.ww.value = state.settings.windowWidth;
                            els.inputs.wc.value = state.settings.windowCenter;
                            els.labels.ww.textContent = Math.round(state.settings.windowWidth);
                            els.labels.wc.textContent = Math.round(state.settings.windowCenter);

                            renderAll();
                            updateVTKVolume(); // update 3D if needed
                            try { render3D(); } catch (e) { }

                            const dur = Math.round(performance.now() - start);
                            els.inputs.opStatus.textContent = `Completed: ${op} (${dur}ms)`;
                        } catch (err) {
                            console.error(err);
                            els.inputs.opStatus.textContent = `Error: ${err.message}`;
                            alert('Operation failed: ' + err.message);
                        } finally {
                            setTimeout(() => els.inputs.opStatus.classList.add('hidden'), 3000);
                        }
                    }, 50);
                }
            });
        }

        // Render quality slider: map 1..100 to visual/perf tradeoff
        const renderQualityEl = document.getElementById('input-render-quality');
        const renderQualityVal = document.getElementById('val-render-quality');
        if (renderQualityEl) {
            renderQualityEl.value = String(state.settings.renderQuality || 70);
            if (renderQualityVal) renderQualityVal.textContent = String(renderQualityEl.value);
            renderQualityEl.addEventListener('input', (e) => {
                const q = Number(e.target.value);
                state.settings.renderQuality = q;
                if (renderQualityVal) renderQualityVal.textContent = String(q);
                try { updateVTKVolume(); } catch (err) { }
                _3dCache.lastQuality = null;
                _3dCache.glPoints = null;
                _3dRequestRender();
                try { renderOptimizedFallback3D(); } catch (err) { }
            });
        }

        // Options
        els.inputs.crosshair.addEventListener('change', (e) => {
            state.settings.showCrosshair = e.target.checked;
            renderAll();
        });
        els.inputs.invert.addEventListener('change', (e) => {
            state.settings.invert = e.target.checked;
            renderAll();
        });
        els.inputs.maskCheck.addEventListener('change', (e) => {
            state.settings.showMask = e.target.checked;
            renderAll();
            render3D(); // Mask affects 3D too
        });
        els.inputs.colormap.addEventListener('change', (e) => {
            state.settings.colorMap = e.target.value;
            renderAll();
        });
        if (els.inputs.dualCheck) {
            els.inputs.dualCheck.addEventListener('change', (e) => {
                state.settings.dualViewEnabled = e.target.checked;
                renderAll();
                render3D();
            });
        }
        if (els.inputs.dualOpacity) {
            const dualVal = document.getElementById('val-dual-opacity');
            els.inputs.dualOpacity.addEventListener('input', (e) => {
                const v = Number(e.target.value);
                state.settings.dualViewOpacity = v;
                if (dualVal) dualVal.textContent = String(v.toFixed(2));
                renderAll();
            });
        }
        if (els.inputs.dualMode) {
            els.inputs.dualMode.value = state.settings.dualMode || 'blend';
            els.inputs.dualMode.addEventListener('change', (e) => {
                state.settings.dualMode = e.target.value;
                renderAll();
            });
        }
        els.inputs.btnReset.addEventListener('click', () => {
            if (state.volume) {
                const d = state.volume.dims;
                state.crosshair = { x: Math.floor(d.x / 2), y: Math.floor(d.y / 2), z: Math.floor(d.z / 2) };
                resetViews();
                renderAll();
            }
        });

        // Viewport Interactions
        ['axial', 'sagittal', 'coronal'].forEach(axis => {
            const container = els.viewports[axis];

            // Prevent default context menu
            container.addEventListener('contextmenu', e => e.preventDefault());

            container.addEventListener('mousedown', (e) => {
                if (!state.volume) return;
                setActiveViewport(axis);

                const startX = e.clientX;
                const startY = e.clientY;
                const startPan = { ...state.ui.viewports[axis].pan };
                const tool = state.ui.tool || 'nav';

                // Helper to paint
                const paintAt = (clientX, clientY) => {
                    const canvas = container.querySelector('canvas');
                    const rect = canvas.getBoundingClientRect(); // Get CSS size
                    const vpState = state.ui.viewports[axis];
                    const d = state.volume.dims;

                    let w, h;
                    if (axis === 'axial') { w = d.x; h = d.y; }
                    else if (axis === 'sagittal') { w = d.y; h = d.z; }
                    else { w = d.x; h = d.z; }

                    // Use rect (CSS pixels) instead of canvas.width (buffer pixels)
                    const scaleX = rect.width / w;
                    const scaleY = rect.height / h;
                    const baseScale = Math.min(scaleX, scaleY);
                    const totalScale = baseScale * vpState.zoom;

                    const offsetX = (rect.width - w * baseScale) / 2;
                    const offsetY = (rect.height - h * baseScale) / 2;

                    const mouseX = clientX - rect.left;
                    const mouseY = clientY - rect.top;

                    // Reverse the transformation precisely
                    const imgX = (mouseX - (offsetX + vpState.pan.x)) / totalScale;
                    const imgY = (mouseY - (offsetY + vpState.pan.y)) / totalScale;

                    const ix = Math.floor(imgX);
                    const iy = Math.floor(imgY);

                    if (ix >= 0 && ix < w && iy >= 0 && iy < h) {
                        // Paint Circle
                        const r = Number(state.ui.brushSize) || 5;
                        const r2 = r * r;

                        // Create mask if missing
                        if (!state.mask) {
                            const size = d.x * d.y * d.z;
                            state.mask = { dims: d, data: new Float32Array(size) };
                            state.settings.showMask = true;
                            els.inputs.maskCheck.checked = true;
                            document.getElementById('group-mask').classList.remove('opacity-50', 'pointer-events-none');
                        }

                        const strideXY = d.x * d.y;
                        let zSlice = 0;
                        if (axis === 'axial') zSlice = state.crosshair.z;
                        else if (axis === 'sagittal') zSlice = state.crosshair.x;
                        else zSlice = state.crosshair.y;

                        const val = (tool === 'erase') ? 0 : 1; // Default label 1

                        // Loop bounding box
                        for (let dy = -r; dy <= r; dy++) {
                            for (let dx = -r; dx <= r; dx++) {
                                if (dx * dx + dy * dy <= r2) {
                                    const px = ix + dx;
                                    const py = iy + dy;
                                    if (px >= 0 && px < w && py >= 0 && py < h) {
                                        // Map 2D -> 3D index
                                        let vx, vy, vz;
                                        if (axis === 'axial') {
                                            vx = px;
                                            vy = (d.y - 1) - py; // Match rendering flip
                                            vz = zSlice;
                                        }
                                        else if (axis === 'sagittal') {
                                            vx = zSlice;
                                            vy = px;
                                            vz = (d.z - 1) - py; // Match rendering flip
                                        }
                                        else {
                                            vx = px;
                                            vy = zSlice;
                                            vz = (d.z - 1) - py; // Match rendering flip
                                        }

                                        if (vx >= 0 && vx < d.x && vy >= 0 && vy < d.y && vz >= 0 && vz < d.z) {
                                            const idx = vx + vy * d.x + vz * strideXY;
                                            state.mask.data[idx] = val;
                                        }
                                    }
                                }
                            }
                        }
                        drawViewport(axis);
                    }
                };

                // Mode detection
                const isPan = e.button === 2 || (e.button === 0 && e.shiftKey);

                if (tool !== 'nav' && !isPan) {
                    // Start Painting
                    state.ui.isPainting = true;
                    paintAt(e.clientX, e.clientY);
                }

                const onMove = (mv) => {
                    if (state.ui.isPainting) {
                        paintAt(mv.clientX, mv.clientY);
                        return;
                    }

                    if (isPan) {
                        // PAN LOGIC
                        state.ui.viewports[axis].pan.x = startPan.x + (mv.clientX - startX);
                        state.ui.viewports[axis].pan.y = startPan.y + (mv.clientY - startY);
                        drawViewport(axis);
                    } else if (tool === 'nav') {
                        // CROSSHAIR LOGIC
                        const canvas = container.querySelector('canvas');
                        const rect = canvas.getBoundingClientRect();
                        const vpState = state.ui.viewports[axis];

                        let w, h;
                        const d = state.volume.dims;
                        if (axis === 'axial') { w = d.x; h = d.y; }
                        else if (axis === 'sagittal') { w = d.y; h = d.z; }
                        else if (axis === 'coronal') { w = d.x; h = d.z; }

                        // Use CSS pixels (rect) for scaling calculation
                        const scaleX = rect.width / w;
                        const scaleY = rect.height / h;
                        const baseScale = Math.min(scaleX, scaleY);
                        const totalScale = baseScale * vpState.zoom;

                        const offsetX = (rect.width - w * baseScale) / 2;
                        const offsetY = (rect.height - h * baseScale) / 2;

                        const mouseX = (mv.clientX - rect.left);
                        const mouseY = (mv.clientY - rect.top);

                        // Precise inverse transform
                        // Pan is stored in CSS pixels, applied before scaling, so scale it by baseScale
                        const imgX = (mouseX - offsetX - vpState.pan.x * baseScale) / (baseScale * vpState.zoom);
                        const imgY = (mouseY - offsetY - vpState.pan.y * baseScale) / (baseScale * vpState.zoom);

                        if (axis === 'axial') {
                            state.crosshair.x = Math.max(0, Math.min(d.x - 1, Math.floor(imgX)));
                            // Inverse the Y calculation
                            state.crosshair.y = Math.max(0, Math.min(d.y - 1, (d.y - 1) - Math.floor(imgY)));
                        } else if (axis === 'sagittal') {
                            state.crosshair.y = Math.max(0, Math.min(d.y - 1, Math.floor(imgX)));
                            // Inverse the Z calculation
                            state.crosshair.z = Math.max(0, Math.min(d.z - 1, (d.z - 1) - Math.floor(imgY)));
                        } else if (axis === 'coronal') {
                            state.crosshair.x = Math.max(0, Math.min(d.x - 1, Math.floor(imgX)));
                            // Inverse the Z calculation
                            state.crosshair.z = Math.max(0, Math.min(d.z - 1, (d.z - 1) - Math.floor(imgY)));
                        }
                        renderAll();
                    }
                };

                const onUp = () => {
                    if (state.ui.isPainting) {
                        state.ui.isPainting = false;
                        // Trigger mask refresh for labels and 3D
                        populateLabelColorUI();
                        updateVTKVolume();
                        try { render3D(); } catch (e) { }
                    }
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                };

                window.addEventListener('mousemove', onMove);
                window.addEventListener('mouseup', onUp);
            });

            // Zoom (Wheel)
            container.addEventListener('wheel', (e) => {
                if (!state.volume) return;
                e.preventDefault();

                // If Shift is pressed or specific mode -> Zoom
                // Default -> Slice Scroll

                if (e.ctrlKey || e.metaKey) {
                    // ZOOM
                    const zoomSpeed = 0.1;
                    const newZoom = state.ui.viewports[axis].zoom - Math.sign(e.deltaY) * zoomSpeed;
                    state.ui.viewports[axis].zoom = Math.max(0.1, Math.min(10, newZoom));
                    drawViewport(axis);
                } else {
                    // SLICE SCROLL
                    const d = state.volume.dims;
                    const dir = Math.sign(e.deltaY);
                    if (axis === 'axial') state.crosshair.z = Math.max(0, Math.min(d.z - 1, state.crosshair.z + dir));
                    if (axis === 'sagittal') state.crosshair.x = Math.max(0, Math.min(d.x - 1, state.crosshair.x + dir));
                    if (axis === 'coronal') state.crosshair.y = Math.max(0, Math.min(d.y - 1, state.crosshair.y + dir));
                    renderAll();
                }
            }, { passive: false });
        });

        // 3D Rotation (pointer events + inertia)
        const v3d = els.viewports.v3d;
        const _v3dContainer = v3d.parentElement;
        _v3dContainer.addEventListener('pointerdown', (e) => {
            if (!state.volume) return;

            if (typeof vtk !== 'undefined' && state.ui.vtk && state.ui.vtk.initialized) {
                return;
            }

            e.preventDefault();
            _v3dContainer.setPointerCapture(e.pointerId);
            let lastX = e.clientX;
            let lastY = e.clientY;
            state.ui._3dRotateVel.x = 0;
            state.ui._3dRotateVel.y = 0;
            _3dStartLoop();

            const onPointerMove = (mv) => {
                const dx = mv.clientX - lastX;
                const dy = mv.clientY - lastY;
                state.ui.rotate3D.x += dy * 0.01;
                state.ui.rotate3D.y += dx * 0.01;
                state.ui._3dRotateVel.x = dy * 0.002;
                state.ui._3dRotateVel.y = dx * 0.002;
                lastX = mv.clientX;
                lastY = mv.clientY;
            };

            const onUp = (up) => {
                try { _v3dContainer.releasePointerCapture(e.pointerId); } catch (err) { }
                _v3dContainer.removeEventListener('pointermove', onPointerMove);
                _v3dContainer.removeEventListener('pointerup', onUp);
                _v3dContainer.removeEventListener('pointercancel', onUp);
            };

            _v3dContainer.addEventListener('pointermove', onPointerMove);
            _v3dContainer.addEventListener('pointerup', onUp);
            _v3dContainer.addEventListener('pointercancel', onUp);
        });

        _v3dContainer.addEventListener('dblclick', () => {
            state.ui.rotate3D = { x: 0, y: 0 };
            state.ui._3dRotateVel = { x: 0, y: 0 };
            _3dRequestRender();

            if (typeof vtk !== 'undefined' && state.ui.vtk && state.ui.vtk.initialized) {
                if (state.ui.vtk.renderer) {
                    state.ui.vtk.renderer.resetCamera();
                    if (state.ui.vtk.renderWindow) state.ui.vtk.renderWindow.render();
                }
            } else {
                renderOptimizedFallback3D();
            }
        });

        // Keyboard Shortcuts (Enhanced)
        window.addEventListener('keydown', (e) => {
            // Check if user is typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

            const shortcutsModal = document.getElementById('shortcuts-modal');

            // Toggle shortcuts help
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                e.preventDefault();
                shortcutsModal.classList.toggle('hidden');
                return;
            }

            // Close shortcuts modal
            if (e.key === 'Escape') {
                shortcutsModal.classList.add('hidden');
                return;
            }

            // Undo/Redo
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    historyManager.undo();
                    return;
                }
                if (e.key === 'y' || e.key === 'Y') {
                    e.preventDefault();
                    historyManager.redo();
                    return;
                }
            }

            // Viewport focus: 1-4
            const setTool = (toolName) => {
                const radio = document.querySelector(`input[name="tool"][value="${toolName}"]`);
                if (radio) {
                    radio.checked = true;
                    state.ui.tool = toolName;
                }
            };

            if (e.key === '1') { setActiveViewport('axial'); return; }
            if (e.key === '2') { setActiveViewport('coronal'); return; }
            if (e.key === '3') { setActiveViewport('sagittal'); return; }
            if (e.key === '4') { setActiveViewport('3d'); return; }

            // Tool shortcuts
            if (e.key === 'n' || e.key === 'N') { setTool('nav'); return; }
            if (e.key === 'b' || e.key === 'B') { setTool('brush'); return; }
            if (e.key === 'e' || e.key === 'E') { setTool('erase'); return; }
            if (e.key === 'm' || e.key === 'M') { setTool('measure'); return; }

            // Reset view
            if (e.key === 'r' || e.key === 'R') {
                if (state.volume) {
                    const d = state.volume.dims;
                    state.crosshair = { x: Math.floor(d.x / 2), y: Math.floor(d.y / 2), z: Math.floor(d.z / 2) };
                    resetViews();
                    renderAll();
                }
                return;
            }

            // Toggle sidebar
            if (e.key === 'Tab') {
                e.preventDefault();
                if (typeof toggleSidebar === 'function') toggleSidebar();
                return;
            }


            // Arrow key navigation (existing behavior)
            if (!state.volume) return;
            const axis = state.activeAxis;
            const d = state.volume.dims;
            let changed = false;

            if (e.key === 'ArrowUp') {
                if (axis === 'axial') state.crosshair.z = Math.min(d.z - 1, state.crosshair.z + 1);
                if (axis === 'sagittal') state.crosshair.x = Math.min(d.x - 1, state.crosshair.x + 1);
                if (axis === 'coronal') state.crosshair.y = Math.min(d.y - 1, state.crosshair.y + 1);
                changed = true;
            } else if (e.key === 'ArrowDown') {
                if (axis === 'axial') state.crosshair.z = Math.max(0, state.crosshair.z - 1);
                if (axis === 'sagittal') state.crosshair.x = Math.max(0, state.crosshair.x - 1);
                if (axis === 'coronal') state.crosshair.y = Math.max(0, state.crosshair.y - 1);
                changed = true;
            }

            if (changed) {
                e.preventDefault();
                renderAll();
            }
        });

        // Window Resize Handling
        window.addEventListener('resize', () => {
            renderAll();
            render3D();
        });

        // Fullscreen Toggle Logic
        document.querySelectorAll('.btn-fullscreen').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger crosshair move

                const viewport = btn.closest('.viewport');
                const isMaximized = viewport.classList.contains('maximized');

                // Remove maximized from all others
                document.querySelectorAll('.viewport').forEach(v => v.classList.remove('maximized'));

                if (!isMaximized) {
                    viewport.classList.add('maximized');
                    btn.textContent = '‚ùê'; // Change icon to "restore"
                } else {
                    btn.textContent = '‚õ∂'; // Change icon back to "expand"
                }

                // Crucial: Re-render after the CSS transition/layout change
                // We use a small timeout to ensure the DOM has updated dimensions
                setTimeout(() => {
                    renderAll();
                    if (viewport.id === 'view-3d') render3D();
                }, 50);
            });
        });

        async function runRemoteSegmentation() {
            // 1. Check if volume is loaded
            if (!state.volume || !els.inputs.fileMri.files[0]) {
                alert("Please load an MRI file from your disk first.");
                return;
            }

            const file = els.inputs.fileMri.files[0];
            const formData = new FormData();
            formData.append("file", file);

            // Update UI
            els.labels.loading.textContent = "Uploading to Neural Network...";
            els.labels.loading.classList.remove('hidden');

            try {
                // 2. Send to Backend
                const response = await fetch("http://localhost:8080/process/segment", {
                    method: "POST",
                    body: formData
                });

                if (!response.ok) throw new Error("Backend Error: " + response.statusText);

                // 3. Receive Blob (Mask)
                els.labels.loading.textContent = "Downloading Mask...";
                const blob = await response.blob();

                // 4. Create File object and reuse your existing handleMaskLoad logic
                const maskFile = new File([blob], "auto_mask.nii.gz", { type: "application/gzip" });
                await handleMaskLoad(maskFile);

                alert("Deep Learning Segmentation Complete!");

            } catch (err) {
                console.error(err);
                alert("Segmentation Failed: " + err.message);
            } finally {
                els.labels.loading.classList.add('hidden');
            }
        }

        // ==========================================
        // QUICK WINS: New Feature Event Handlers
        // ==========================================

        // --- Drag & Drop ---
        const dragOverlay = document.getElementById('drag-overlay');
        let dragCounter = 0;

        document.body.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (dragCounter === 1) {
                dragOverlay.classList.remove('hidden');
            }
        });

        document.body.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dragOverlay.classList.add('hidden');
            }
        });

        document.body.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.body.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            dragOverlay.classList.add('hidden');

            const files = e.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];
            const name = file.name.toLowerCase();

            if (name.endsWith('.nii') || name.endsWith('.nii.gz')) {
                // Auto-detect: if filename contains 'mask' or 'seg', treat as mask
                if (name.includes('mask') || name.includes('seg') || name.includes('label')) {
                    if (state.volume) {
                        await handleMaskLoad(file);
                    } else {
                        alert('Load an MRI volume first before loading a mask.');
                    }
                } else {
                    await handleMriLoad(file);
                }
            } else {
                alert('Please drop a NIfTI file (.nii or .nii.gz)');
            }
        });

        // --- Shortcuts Modal Close ---
        document.getElementById('btn-close-shortcuts')?.addEventListener('click', () => {
            document.getElementById('shortcuts-modal').classList.add('hidden');
        });

        // --- Undo/Redo Buttons ---
        document.getElementById('btn-undo')?.addEventListener('click', () => {
            historyManager.undo();
        });

        document.getElementById('btn-redo')?.addEventListener('click', () => {
            historyManager.redo();
        });

        // --- Clear Measurements ---
        document.getElementById('btn-clear-measurements')?.addEventListener('click', () => {
            state.ui.measurements = [];
            state.ui.measureStart = null;
            // Remove measurement labels from DOM
            document.querySelectorAll('.measurement-label').forEach(el => el.remove());
            renderAll();
        });

        // --- Export Mask as NIfTI ---
        document.getElementById('btn-export-mask')?.addEventListener('click', () => {
            if (!state.mask || !state.volume) {
                alert('No mask to export. Create a segmentation first.');
                return;
            }

            try {
                // Build a minimal NIfTI-1 header
                const dims = state.mask.dims;
                const voxelDims = state.volume.voxelDims || { x: 1, y: 1, z: 1 };
                const dataSize = dims.x * dims.y * dims.z;

                // Header size: 348 bytes for NIfTI-1
                const headerSize = 348;
                const voxOffset = 352; // Data starts after header + 4 byte extension
                const totalSize = voxOffset + dataSize; // Uint8 = 1 byte per voxel

                const buffer = new ArrayBuffer(totalSize);
                const view = new DataView(buffer);

                // sizeof_hdr
                view.setInt32(0, 348, true);

                // dim[0..7] at byte 40
                view.setInt16(40, 3, true);  // dim[0] = 3 dimensions
                view.setInt16(42, dims.x, true);
                view.setInt16(44, dims.y, true);
                view.setInt16(46, dims.z, true);
                view.setInt16(48, 1, true);
                view.setInt16(50, 1, true);
                view.setInt16(52, 1, true);
                view.setInt16(54, 1, true);

                // datatype = 2 (uint8)
                view.setInt16(70, 2, true);
                // bitpix = 8
                view.setInt16(72, 8, true);

                // pixdim at byte 76
                view.setFloat32(76, 1.0, true);  // pixdim[0] (qfac)
                view.setFloat32(80, voxelDims.x, true);
                view.setFloat32(84, voxelDims.y, true);
                view.setFloat32(88, voxelDims.z, true);

                // vox_offset
                view.setFloat32(108, voxOffset, true);

                // scl_slope = 1, scl_inter = 0
                view.setFloat32(112, 1.0, true);
                view.setFloat32(116, 0.0, true);

                // magic "n+1" at byte 344
                view.setUint8(344, 0x6E); // 'n'
                view.setUint8(345, 0x2B); // '+'
                view.setUint8(346, 0x31); // '1'
                view.setUint8(347, 0x00);

                // Extension: 4 bytes of zeros
                view.setInt32(348, 0, true);

                // Write mask data as uint8
                const maskData = new Uint8Array(buffer, voxOffset, dataSize);
                for (let i = 0; i < dataSize; i++) {
                    maskData[i] = Math.round(state.mask.data[i]) > 0 ? Math.min(255, Math.max(0, Math.round(state.mask.data[i]))) : 0;
                }

                // Download
                const blob = new Blob([buffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mask_export.nii';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);

                alert('Mask exported successfully!');
            } catch (err) {
                alert('Export failed: ' + err.message);
            }
        });

        // --- Export Current Slice as PNG ---
        document.getElementById('btn-export-slice')?.addEventListener('click', () => {
            if (!state.volume) {
                alert('No volume loaded.');
                return;
            }

            const axis = state.activeAxis;
            if (axis === '3d') {
                alert('Please select a 2D viewport (Axial, Coronal, or Sagittal) to export.');
                return;
            }

            const container = els.viewports[axis];
            const canvas = container?.querySelector('canvas');
            if (!canvas) {
                alert('Canvas not found.');
                return;
            }

            try {
                const dataUrl = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `slice_${axis}_${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                a.remove();
            } catch (err) {
                alert('Export failed: ' + err.message);
            }
        });

        // --- Hook history push into brush painting ---
        // Override mousedown listener to add history push before painting starts
        (function () {
            const originalCreatePaintHandler = () => {
                // This will be hooked in the viewport mousedown handler
            };

            // Add history push trigger when painting starts
            ['axial', 'sagittal', 'coronal'].forEach(axis => {
                const container = els.viewports[axis];
                if (!container) return;

                container.addEventListener('mousedown', (e) => {
                    const tool = state.ui.tool;
                    if ((tool === 'brush' || tool === 'erase') && e.button === 0 && !e.shiftKey) {
                        // Push history before starting to paint
                        historyManager.push();
                    }
                }, true); // Capture phase to run before the existing handler
            });
        })();

        // --- Measurement Tool Integration ---
        // Note: The measurement handling is integrated into viewport mousedown
        // We need to add measurement line drawing to renderAll
        const originalRenderAll = typeof renderAll === 'function' ? renderAll : null;

        // Extend renderAll to draw measurements
        const renderMeasurements = () => {
            // Remove old measurement labels
            document.querySelectorAll('.measurement-label').forEach(el => el.remove());

            state.ui.measurements.forEach((m, idx) => {
                const container = els.viewports[m.axis];
                if (!container) return;

                const canvas = container.querySelector('canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const d = state.volume?.dims;
                if (!d) return;

                // Convert voxel coords to canvas coords
                let w, h;
                if (m.axis === 'axial') { w = d.x; h = d.y; }
                else if (m.axis === 'sagittal') { w = d.y; h = d.z; }
                else { w = d.x; h = d.z; }

                const vpState = state.ui.viewports[m.axis];
                const scaleX = canvas.width / w;
                const scaleY = canvas.height / h;
                const baseScale = Math.min(scaleX, scaleY);

                const offsetX = (canvas.width - w * baseScale) / 2;
                const offsetY = (canvas.height - h * baseScale) / 2;

                const x1 = offsetX + m.start.x * baseScale * vpState.zoom + vpState.pan.x;
                const y1 = offsetY + m.start.y * baseScale * vpState.zoom + vpState.pan.y;
                const x2 = offsetX + m.end.x * baseScale * vpState.zoom + vpState.pan.x;
                const y2 = offsetY + m.end.y * baseScale * vpState.zoom + vpState.pan.y;

                // Draw line
                ctx.save();
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Draw endpoints
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(x1, y1, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x2, y2, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Add label
                const label = document.createElement('div');
                label.className = 'measurement-label';
                label.textContent = `${m.distance.toFixed(2)} mm`;
                label.style.left = `${(x1 + x2) / 2 + container.offsetLeft}px`;
                label.style.top = `${(y1 + y2) / 2 + container.offsetTop}px`;
                container.appendChild(label);
            });
        };

        // Hook into renderAll to also render measurements
        const hookRenderAll = () => {
            const origRenderAllFn = window.renderAll || (() => { });
            if (origRenderAllFn._hooked) return;

            window.renderAll = function (...args) {
                origRenderAllFn.apply(this, args);
                if (state.ui.measurements.length > 0) {
                    setTimeout(renderMeasurements, 10);
                }
            };
            window.renderAll._hooked = true;
        };

        // Delay hook to ensure renderAll is defined
        setTimeout(hookRenderAll, 100);

        // Add measurement click handler to viewports
        ['axial', 'sagittal', 'coronal'].forEach(axis => {
            const container = els.viewports[axis];
            if (!container) return;

            container.addEventListener('click', (e) => {
                if (state.ui.tool !== 'measure' || !state.volume) return;

                const canvas = container.querySelector('canvas');
                if (!canvas) return;

                const rect = canvas.getBoundingClientRect();
                const d = state.volume.dims;
                const voxelDims = state.volume.voxelDims || { x: 1, y: 1, z: 1 };

                let w, h;
                if (axis === 'axial') { w = d.x; h = d.y; }
                else if (axis === 'sagittal') { w = d.y; h = d.z; }
                else { w = d.x; h = d.z; }

                const vpState = state.ui.viewports[axis];
                const scaleX = rect.width / w;
                const scaleY = rect.height / h;
                const baseScale = Math.min(scaleX, scaleY);
                const totalScale = baseScale * vpState.zoom;

                const offsetX = (rect.width - w * baseScale) / 2;
                const offsetY = (rect.height - h * baseScale) / 2;

                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const imgX = (mouseX - offsetX - vpState.pan.x) / totalScale;
                const imgY = (mouseY - offsetY - vpState.pan.y) / totalScale;

                const clickPoint = { x: imgX, y: imgY };

                if (!state.ui.measureStart) {
                    // First click - start point
                    state.ui.measureStart = { axis, ...clickPoint };
                } else if (state.ui.measureStart.axis === axis) {
                    // Second click - end point (same axis)
                    const start = state.ui.measureStart;
                    const end = clickPoint;

                    // Calculate distance in mm
                    let voxX, voxY;
                    if (axis === 'axial') {
                        voxX = voxelDims.x;
                        voxY = voxelDims.y;
                    } else if (axis === 'sagittal') {
                        voxX = voxelDims.y;
                        voxY = voxelDims.z;
                    } else {
                        voxX = voxelDims.x;
                        voxY = voxelDims.z;
                    }

                    const dx = (end.x - start.x) * voxX;
                    const dy = (end.y - start.y) * voxY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    state.ui.measurements.push({
                        axis,
                        start: { x: start.x, y: start.y },
                        end: { x: end.x, y: end.y },
                        distance
                    });

                    state.ui.measureStart = null;
                    renderAll();
                } else {
                    // Different axis - reset
                    state.ui.measureStart = { axis, ...clickPoint };
                }
            });
        });

        // ==========================================
        // PHASE 2: Sidebar, Histogram, Screenshot
        // ==========================================

        // --- Collapsible Sidebar ---
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');

        function toggleSidebar() {
            const isCollapsed = sidebar.classList.toggle('collapsed');
            sidebarToggle.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
            // Trigger resize for viewports
            setTimeout(() => {
                renderAll();
                try { render3D(); } catch (e) { }
            }, 350);
        }

        sidebarToggle?.addEventListener('click', toggleSidebar);

        // --- Histogram ---
        const histogramCanvas = document.getElementById('histogram-canvas');
        const histogramCtx = histogramCanvas?.getContext('2d');
        let histogramData = null;

        function computeHistogram() {
            if (!state.volume) return null;

            const data = state.volume.data;
            const bins = 256;
            const min = state.volume.min;
            const max = state.volume.max;
            const range = max - min;

            if (range <= 0) return null;

            const hist = new Float32Array(bins);
            const step = Math.max(1, Math.floor(data.length / 100000)); // Subsample large volumes

            for (let i = 0; i < data.length; i += step) {
                const idx = Math.floor(((data[i] - min) / range) * (bins - 1));
                if (idx >= 0 && idx < bins) hist[idx]++;
            }

            // Normalize
            let maxCount = 0;
            for (let i = 0; i < bins; i++) {
                if (hist[i] > maxCount) maxCount = hist[i];
            }

            return { hist, min, max, maxCount, bins };
        }

        function drawHistogram() {
            if (!histogramCanvas || !histogramCtx) return;

            const rect = histogramCanvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            histogramCanvas.width = rect.width * dpr;
            histogramCanvas.height = rect.height * dpr;
            histogramCtx.scale(dpr, dpr);

            const w = rect.width;
            const h = rect.height;

            // Clear
            histogramCtx.fillStyle = '#0f0f0f';
            histogramCtx.fillRect(0, 0, w, h);

            if (!histogramData) {
                histogramData = computeHistogram();
            }

            if (!histogramData) {
                histogramCtx.fillStyle = '#333';
                histogramCtx.font = '11px monospace';
                histogramCtx.textAlign = 'center';
                histogramCtx.fillText('No volume loaded', w / 2, h / 2);
                return;
            }

            const { hist, min, max, maxCount, bins } = histogramData;
            const barWidth = w / bins;

            // Draw histogram bars
            histogramCtx.fillStyle = '#0ea5e940';
            for (let i = 0; i < bins; i++) {
                const barHeight = (hist[i] / maxCount) * (h - 4);
                histogramCtx.fillRect(i * barWidth, h - barHeight, barWidth, barHeight);
            }

            // Draw window/level overlay
            const ww = state.settings.windowWidth;
            const wc = state.settings.windowCenter;
            const range = max - min;

            const winStart = ((wc - ww / 2) - min) / range * w;
            const winEnd = ((wc + ww / 2) - min) / range * w;

            histogramCtx.fillStyle = 'rgba(14, 165, 233, 0.2)';
            histogramCtx.fillRect(winStart, 0, winEnd - winStart, h);

            // Draw window edges
            histogramCtx.strokeStyle = '#0ea5e9';
            histogramCtx.lineWidth = 1;
            histogramCtx.beginPath();
            histogramCtx.moveTo(winStart, 0);
            histogramCtx.lineTo(winStart, h);
            histogramCtx.moveTo(winEnd, 0);
            histogramCtx.lineTo(winEnd, h);
            histogramCtx.stroke();

            // Update labels
            document.getElementById('hist-min').textContent = `Min: ${min.toFixed(0)}`;
            document.getElementById('hist-max').textContent = `Max: ${max.toFixed(0)}`;
        }

        // Histogram interaction
        if (histogramCanvas) {
            let histDragging = false;
            let histDragStart = 0;
            let histStartCenter = 0;

            histogramCanvas.addEventListener('mousedown', (e) => {
                if (!histogramData) return;
                histDragging = true;
                histDragStart = e.clientX;
                histStartCenter = state.settings.windowCenter;
            });

            histogramCanvas.addEventListener('mousemove', (e) => {
                if (!histogramData) return;

                const rect = histogramCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const ratio = x / rect.width;
                const value = histogramData.min + ratio * (histogramData.max - histogramData.min);

                document.getElementById('hist-cursor').textContent = `Val: ${value.toFixed(1)}`;

                if (histDragging) {
                    const dx = e.clientX - histDragStart;
                    const range = histogramData.max - histogramData.min;
                    const delta = (dx / rect.width) * range;

                    // Shift + drag adjusts width, regular drag adjusts center
                    if (e.shiftKey) {
                        state.settings.windowWidth = Math.max(10, state.settings.windowWidth + delta * 0.1);
                    } else {
                        state.settings.windowCenter = histStartCenter + delta;
                    }

                    // Update UI
                    els.inputs.ww.value = state.settings.windowWidth;
                    els.inputs.wc.value = state.settings.windowCenter;
                    els.labels.ww.textContent = Math.round(state.settings.windowWidth);
                    els.labels.wc.textContent = Math.round(state.settings.windowCenter);

                    drawHistogram();
                    renderAll();
                }
            });

            histogramCanvas.addEventListener('mouseup', () => {
                histDragging = false;
            });

            histogramCanvas.addEventListener('mouseleave', () => {
                histDragging = false;
                document.getElementById('hist-cursor').textContent = '-';
            });

            histogramCanvas.addEventListener('click', (e) => {
                if (!histogramData) return;

                const rect = histogramCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const ratio = x / rect.width;
                const value = histogramData.min + ratio * (histogramData.max - histogramData.min);

                state.settings.windowCenter = value;
                els.inputs.wc.value = value;
                els.labels.wc.textContent = Math.round(value);

                drawHistogram();
                renderAll();
            });
        }

        // Hook histogram update into volume loading
        const origHandleMriLoad = handleMriLoad;
        handleMriLoad = async function (file) {
            await origHandleMriLoad(file);
            histogramData = null;
            drawHistogram();
        };

        // --- Screenshot Tool ---
        document.getElementById('btn-screenshot')?.addEventListener('click', async () => {
            if (!state.volume) {
                alert('Load a volume first to take a screenshot.');
                return;
            }

            try {
                // Get all viewport canvases
                const viewports = ['axial', 'coronal', 'sagittal'];
                const canvases = viewports.map(axis => {
                    const container = els.viewports[axis];
                    return container?.querySelector('canvas');
                }).filter(c => c);

                const v3dCanvas = document.getElementById('canvas-3d');

                // Calculate composite dimensions
                const padding = 10;
                const headerHeight = 30;
                const vpWidth = 400;
                const vpHeight = 400;

                // Create composite canvas (2x2 grid)
                const compositeCanvas = document.createElement('canvas');
                compositeCanvas.width = vpWidth * 2 + padding * 3;
                compositeCanvas.height = vpHeight * 2 + padding * 3 + headerHeight;
                const ctx = compositeCanvas.getContext('2d');

                // Background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);

                // Header
                ctx.fillStyle = '#0ea5e9';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText('NeuroView Web Pro', padding, 20);
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                const timestamp = new Date().toLocaleString();
                ctx.fillText(timestamp, compositeCanvas.width - padding - ctx.measureText(timestamp).width, 20);

                // Draw viewports in 2x2 grid
                const positions = [
                    { x: padding, y: headerHeight + padding, label: 'AXIAL' },
                    { x: vpWidth + padding * 2, y: headerHeight + padding, label: 'CORONAL' },
                    { x: padding, y: vpHeight + headerHeight + padding * 2, label: 'SAGITTAL' },
                    { x: vpWidth + padding * 2, y: vpHeight + headerHeight + padding * 2, label: '3D' }
                ];

                // Draw 2D viewports
                for (let i = 0; i < 3 && i < canvases.length; i++) {
                    ctx.drawImage(canvases[i], positions[i].x, positions[i].y, vpWidth, vpHeight);

                    // Label
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(positions[i].x, positions[i].y, 80, 20);
                    ctx.fillStyle = '#0ea5e9';
                    ctx.font = 'bold 11px monospace';
                    ctx.fillText(positions[i].label, positions[i].x + 4, positions[i].y + 14);
                }

                // Draw 3D viewport
                if (v3dCanvas) {
                    ctx.drawImage(v3dCanvas, positions[3].x, positions[3].y, vpWidth, vpHeight);
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(positions[3].x, positions[3].y, 80, 20);
                    ctx.fillStyle = '#eab308';
                    ctx.font = 'bold 11px monospace';
                    ctx.fillText('3D VIEW', positions[3].x + 4, positions[3].y + 14);
                }

                // Download
                const dataUrl = compositeCanvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `neuroview_screenshot_${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                a.remove();

            } catch (err) {
                alert('Screenshot failed: ' + err.message);
            }
        });

        // Add Tab key to toggle sidebar in keyboard handler
        const origKeyHandler = window.addEventListener;

        // Initial histogram draw
        setTimeout(drawHistogram, 500);

        console.log('NeuroView Web Pro - Phase 2 loaded: Collapsible Sidebar, Histogram, Screenshot');
    </script>
</body>

</html>